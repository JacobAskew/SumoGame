//---------------------------------------------------------------------------
#include <fmx.h>
#include <FMX.Dialogs.hpp>
#include <System.UITypes.hpp>  // For colors
#include <map>  // If you still want to use maps
#include <FMX.DialogService.hpp> // Required for TDialogService
#include <FMX.Graphics.hpp>   // For TBitmap
#include <System.SysUtils.hpp>  // Required for UnicodeString conversion
#include <regex>
#include <unordered_map>
#include <unordered_set>
#include <random>
//---------------------------------------------------------------------------
#include "Dohyo.h"
#include "Street.h"
#include "Banzuke.h"
#include "Noboru.h"
#include "Training.h"
#include "Beya.h"
#include "Battle.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.fmx"
#pragma hdrstop
TDohyoForm *DohyoForm;
//---------------------------------------------------------------------------
String DayLabel = "????";
String ClockLabel = "????";
String TimeLabel = "????";
String VSPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\Vs.png";
String FirePath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\fire.png";

int fighter1SkillValue = 0;
int fighter1Total = 0;
int fighter2SkillValue = 0;
int fighter2Total = 0;
int Luck;
int winner;
int winnerIdx;
int loserIdx;
//int i = 0;
std::string fighter1Tactic;
std::string fighter2Tactic;
std::string boutTactic;
int TotalBouts = 49;
int currentBoutIndex = 0;
bool isBanzukeComplete = false;
void BanzukePhaseComplete();

Rikishi* globalFighter1 = nullptr;
Rikishi* globalFighter2 = nullptr;
//---------------------------------------------------------------------------
// Helper function to apply a tint to a pixel
TAlphaColor ApplyTintPixel(TAlphaColor originalColor, TAlphaColor tintColor) {
	// Extract RGB components from the original color
	uint8_t r = (originalColor >> 16) & 0xFF;
	uint8_t g = (originalColor >> 8) & 0xFF;
	uint8_t b = (originalColor >> 0) & 0xFF;

    // Extract RGB components from the tint color
    uint8_t tr = (tintColor >> 16) & 0xFF;
	uint8_t tg = (tintColor >> 8) & 0xFF;
	uint8_t tb = (tintColor >> 0) & 0xFF;

	// Simple blend of the original color with the tint (adjust as needed)
	r = (r + tr) / 2;
	g = (g + tg) / 2;
	b = (b + tb) / 2;

	// Recreate the tinted color and return it
	return (originalColor & 0xFF000000) | (r << 16) | (g << 8) | b;
}

// Function to apply tint to non-transparent pixels of the bitmap
void TintNoTransparent(TBitmap* bitmap, TAlphaColor tintColor) {
	if (!bitmap || bitmap->IsEmpty()) return;  // <-- Added null check

    TBitmapData bitmapData;
	if (bitmap->Map(TMapAccess::ReadWrite, bitmapData)) {
        for (int y = 0; y < bitmap->Height; ++y) {
			for (int x = 0; x < bitmap->Width; ++x) {
				TAlphaColor pixelColor = bitmapData.GetPixel(x, y);
				uint8_t alpha = (pixelColor >> 24) & 0xFF;

                if (alpha > 0) {
					TAlphaColor tintedPixel = ApplyTintPixel(pixelColor, tintColor);
                    bitmapData.SetPixel(x, y, tintedPixel);
                }
			}
        }
		bitmap->Unmap(bitmapData);
    }
}
//---------------------------------------------------------------------------
void UpdateDohyoGUI(Rikishi* fighter1, Rikishi* fighter2, TForm *form) {

	// Some code to update the text which shows the date and time:

	if (currentBoutIndex >= 0 && currentBoutIndex <= 6) {
		DayLabel = "Monday";
	}
	else if (currentBoutIndex >= 7 && currentBoutIndex <= 13) {
		DayLabel = "Tuesday";
	}
	else if (currentBoutIndex >= 14 && currentBoutIndex <= 20) {
		DayLabel = "Wednesday";
	}
	else if (currentBoutIndex >= 21 && currentBoutIndex <= 27) {
		DayLabel = "Thursday";
	}
	else if (currentBoutIndex >= 28 && currentBoutIndex <= 34) {
		DayLabel = "Friday";
	}
	else if (currentBoutIndex >= 35 && currentBoutIndex <= 41) {
		DayLabel = "Saturday";
	}
	else if (currentBoutIndex >= 42 && currentBoutIndex <= 48) {
		DayLabel = "Sunday";
	}
	else {
		TimeLabel = "ERROR";
	}

	if (currentBoutIndex == 0 || currentBoutIndex == 7 || currentBoutIndex == 14 || currentBoutIndex == 21 || currentBoutIndex == 28 || currentBoutIndex == 35 || currentBoutIndex == 42) {
		ClockLabel = "9 AM";
		TimeLabel = "Morning";
	}
	else if (currentBoutIndex == 1 || currentBoutIndex == 8 || currentBoutIndex == 15 || currentBoutIndex == 22 || currentBoutIndex == 29 || currentBoutIndex == 36 || currentBoutIndex == 43) {
		ClockLabel = "10 AM";
		TimeLabel = "Morning";
	}
	else if (currentBoutIndex == 2 || currentBoutIndex == 9 || currentBoutIndex == 16 || currentBoutIndex == 23 || currentBoutIndex == 30 || currentBoutIndex == 37 || currentBoutIndex == 44) {
		ClockLabel = "11 AM";
		TimeLabel = "Morning";
	}
	else if (currentBoutIndex == 3 || currentBoutIndex == 10 || currentBoutIndex == 17 || currentBoutIndex == 24 || currentBoutIndex == 31 || currentBoutIndex == 38 || currentBoutIndex == 45) {
		ClockLabel = "2 PM";
		TimeLabel = "Afternoon";
	}
	else if (currentBoutIndex == 4 || currentBoutIndex == 11 || currentBoutIndex == 18 || currentBoutIndex == 25 || currentBoutIndex == 32 || currentBoutIndex == 39 || currentBoutIndex == 46) {
		ClockLabel = "3 PM";
		TimeLabel = "Afternoon";
	}
	else if (currentBoutIndex == 5 || currentBoutIndex == 12 || currentBoutIndex == 19 || currentBoutIndex == 26 || currentBoutIndex == 33 || currentBoutIndex == 40 || currentBoutIndex == 47) {
		ClockLabel = "7 PM";
		TimeLabel = "Evening";
	}
	else if (currentBoutIndex == 6 || 13 || 20 || 27 || 34 || 41 || 48) {
		ClockLabel = "8 PM";
		TimeLabel = "Evening";
	}
	else {
		ClockLabel = "ERROR";
	}

	DohyoForm->TextDateTime->Text = AnsiString(DayLabel + " " + TimeLabel + " at " + ClockLabel);

	// Update all of the stats and buttons
	// Fighter 1
//	DohyoForm->ButtonWeight1->Text = "Weight: " + IntToStr(fighter1->weight);
//	DohyoForm->ButtonEndurance1->Text = "Endurance: " + IntToStr(fighter1->endurance);
//	DohyoForm->ButtonTechnique1->Text = "Technique: " + IntToStr(fighter1->technique);
//	DohyoForm->ButtonSpeed1->Text = "Speed: " + IntToStr(fighter1->speed);
//	DohyoForm->ButtonStrength1->Text = "Strength: " + IntToStr(fighter1->strength);
//	DohyoForm->EditAge1->Text = "Age: " + IntToStr(fighter1->age);
//	DohyoForm->EditSpirit1->Text = "Spirit: " + IntToStr(fighter1->spirit);
	DohyoForm->TextOwner1->Text = AnsiString("(" + AnsiString(fighter1->owner.c_str()) + ")");
	if (AnsiString(fighter1->owner.c_str()) == "P1") {
		DohyoForm->TextOwner1->TextSettings->FontColor = TAlphaColorRec::Red;
	}
	else if (AnsiString(fighter1->owner.c_str()) == "P2") {
		DohyoForm->TextOwner1->TextSettings->FontColor = TAlphaColorRec::Blue;
	}
	else if (AnsiString(fighter1->owner.c_str()) == "P3") {
		DohyoForm->TextOwner1->TextSettings->FontColor = TAlphaColorRec::Yellow;
	}
	else if (AnsiString(fighter1->owner.c_str()) == "P4") {
		DohyoForm->TextOwner1->TextSettings->FontColor = TAlphaColorRec::Green;
	}
	else if (AnsiString(fighter1->owner.c_str()) == "P5") {
		DohyoForm->TextOwner1->TextSettings->FontColor = TAlphaColorRec::Grey;
	}
	else {
		DohyoForm->TextOwner1->TextSettings->FontColor = TAlphaColorRec::Magenta;
	}

//	DohyoForm->TextRank1->Text = AnsiString(AnsiString(fighter1->rank.c_str()));
	DohyoForm->TextFighter1->Text = AnsiString(fighter1->name.c_str());
//	DohyoForm->EditRecord1->Text = "Standing: " + IntToStr(fighter1->wins) + " / " + IntToStr(fighter1->losses);
	// Fighter 2
//	DohyoForm->ButtonWeight2->Text = "Weight: " + IntToStr(fighter2->weight);
//	DohyoForm->ButtonEndurance2->Text = "Endurance: " + IntToStr(fighter2->endurance);
//	DohyoForm->ButtonTechnique2->Text = "Technique: " + IntToStr(fighter2->technique);
//	DohyoForm->ButtonSpeed2->Text = "Speed: " + IntToStr(fighter2->speed);
//	DohyoForm->ButtonStrength2->Text = "Strength: " + IntToStr(fighter2->strength);
//	DohyoForm->EditAge2->Text = "Age: " + IntToStr(fighter2->age);
//	DohyoForm->EditSpirit2->Text = "Spirit: " + IntToStr(fighter2->spirit);
	DohyoForm->TextOwner2->Text = AnsiString("(" + AnsiString(fighter2->owner.c_str()) + ")");
	if (AnsiString(fighter2->owner.c_str()) == "P1") {
		DohyoForm->TextOwner2->TextSettings->FontColor = TAlphaColorRec::Red;
	}
	else if (AnsiString(fighter2->owner.c_str()) == "P2") {
		DohyoForm->TextOwner2->TextSettings->FontColor = TAlphaColorRec::Blue;
	}
	else if (AnsiString(fighter2->owner.c_str()) == "P3") {
		DohyoForm->TextOwner2->TextSettings->FontColor = TAlphaColorRec::Yellow;
	}
	else if (AnsiString(fighter2->owner.c_str()) == "P4") {
		DohyoForm->TextOwner2->TextSettings->FontColor = TAlphaColorRec::Green;
	}
	else if (AnsiString(fighter2->owner.c_str()) == "P5") {
		DohyoForm->TextOwner2->TextSettings->FontColor = TAlphaColorRec::Grey;
	}
	else {
		DohyoForm->TextOwner2->TextSettings->FontColor = TAlphaColorRec::Magenta;
	}
//	DohyoForm->TextRank2->Text = AnsiString(AnsiString(fighter2->rank.c_str()));
	DohyoForm->TextFighter2->Text = AnsiString(fighter2->name.c_str());
//	DohyoForm->EditRecord2->Text = "Standing: " + IntToStr(fighter2->wins) + " / " + IntToStr(fighter2->losses);

	// Update all of the images
	std::regex numRegex(R"(\d+)");
	// VS symbol
	TImage* imagevs = dynamic_cast<TImage*>(form->FindComponent("ImageVS"));
	AnsiString fullPathVS = VSPath;
	imagevs->Bitmap->LoadFromFile(fullPathVS);
	// Arena
	TImage* imagefire = dynamic_cast<TImage*>(form->FindComponent("ImageFightBackground"));
	AnsiString fullPathFire = FirePath;
	imagefire->Bitmap->LoadFromFile(fullPathFire);
	// Update Fighter 1 images
	TImage* imageRikishi1 = dynamic_cast<TImage*>(form->FindComponent("ImageRikishi1"));
	if (!imageRikishi1) {
		ShowMessage("Error: ImageRikishi1 component not found.");
		return;
	}
	if (imageRikishi1) {
		AnsiString fullPath1 = RikishiPath + IntToStr(fighter1->spirit) + ".png";
		imageRikishi1->Bitmap->LoadFromFile(fullPath1);
	}
	TImage* imageBelt1 = dynamic_cast<TImage*>(form->FindComponent("ImageBelt1"));
	if (imageBelt1) {
		AnsiString fullPathBelt1 = BeltPath + ".png";
		imageBelt1->Bitmap->LoadFromFile(fullPathBelt1);

		std::string colorStr1 = AnsiString(fighter1->colour).c_str();
		std::smatch match1;
//        std::regex numRegex(R"(\d+)");
        if (std::regex_search(colorStr1, match1, numRegex)) {
			UnicodeString extractedNumber1 = UnicodeString(match1.str().c_str());
            TAlphaColor color1 = (TAlphaColor)StrToUInt(extractedNumber1);
			TintNoTransparent(imageBelt1->Bitmap, color1);
        } else {
			ShowMessage("Invalid color format: " + fighter1->colour);
        }
	}
	TImage* imageYokozuna1 = dynamic_cast<TImage*>(form->FindComponent("ImageYokozuna1"));
	if (imageYokozuna1) {
		imageYokozuna1->Visible = (fighter1->rank == "Yokozuna");
		if (fighter1->rank == "Yokozuna") {
			AnsiString fullPathYokozuna1 = YokozunaPath + ".png";
			imageYokozuna1->Bitmap->LoadFromFile(fullPathYokozuna1);
        }
	}
    // Update Fighter 2 images
	TImage* imageRikishi2 = dynamic_cast<TImage*>(form->FindComponent("ImageRikishi2"));
	if (imageRikishi2) {
		AnsiString fullPath2 = RikishiPath + IntToStr(fighter2->spirit) + ".png";
		imageRikishi2->Bitmap->LoadFromFile(fullPath2);
	}
	TImage* imageBelt2 = dynamic_cast<TImage*>(form->FindComponent("ImageBelt2"));
	if (imageBelt2) {
		AnsiString fullPathBelt2 = BeltPath + ".png";
        imageBelt2->Bitmap->LoadFromFile(fullPathBelt2);

		std::string colorStr2 = AnsiString(fighter2->colour).c_str();
		std::smatch match2;
        if (std::regex_search(colorStr2, match2, numRegex)) {
            UnicodeString extractedNumber2 = UnicodeString(match2.str().c_str());
			TAlphaColor color2 = (TAlphaColor)StrToUInt(extractedNumber2);
			TintNoTransparent(imageBelt2->Bitmap, color2);
		} else {
			ShowMessage("Invalid color format: " + fighter2->colour);
		}
	}
	TImage* imageYokozuna2 = dynamic_cast<TImage*>(form->FindComponent("ImageYokozuna2"));
	if (imageYokozuna2) {
		imageYokozuna2->Visible = (fighter2->rank == "Yokozuna");
		if (fighter2->rank == "Yokozuna") {
			AnsiString fullPathYokozuna2 = YokozunaPath + ".png";
			imageYokozuna2->Bitmap->LoadFromFile(fullPathYokozuna2);
		}
	}

	// The skill markers for fighter 1


	// Load and tint skill images
	struct Skill {
		const char* name;
		int value;
		int limit;
		TAlphaColor color;
	};

	Skill skills[] = {
		{"Weight", fighter1->weight, fighter1->weightLimit, TAlphaColorRec::Black},
		{"Endurance", fighter1->endurance, fighter1->enduranceLimit, (TAlphaColor)0xFF00FF00},
		{"Technique", fighter1->technique, fighter1->techniqueLimit, TAlphaColorRec::Blue},
		{"Speed", fighter1->speed, fighter1->speedLimit, TAlphaColorRec::Yellow},
		{"Strength", fighter1->strength, fighter1->strengthLimit, TAlphaColorRec::Red}
	};

	for (const Skill& skill : skills) {
		TImage* skillImage = dynamic_cast<TImage*>(form->FindComponent("Image" + AnsiString(skill.name) + "1"));
		if (skillImage) {
			AnsiString fullPathSkill = SkillPath + IntToStr(skill.value) + IntToStr(skill.limit) + ".png";
			skillImage->Bitmap->LoadFromFile(fullPathSkill);
			TintNoTransparent(skillImage->Bitmap, skill.color);
		}
	}

  // For fighter 2

	Skill skills2[] = {
		{"Weight", fighter2->weight, fighter2->weightLimit, TAlphaColorRec::Black},
		{"Endurance", fighter2->endurance, fighter2->enduranceLimit, (TAlphaColor)0xFF00FF00},
		{"Technique", fighter2->technique, fighter2->techniqueLimit, TAlphaColorRec::Blue},
		{"Speed", fighter2->speed, fighter2->speedLimit, TAlphaColorRec::Yellow},
		{"Strength", fighter2->strength, fighter2->strengthLimit, TAlphaColorRec::Red}
	};

	for (const Skill& skill : skills2) {
		TImage* skillImage = dynamic_cast<TImage*>(form->FindComponent("Image" + AnsiString(skill.name) + "2"));
		if (skillImage) {
			AnsiString fullPathSkill = SkillPath + IntToStr(skill.value) + IntToStr(skill.limit) + ".png";
			skillImage->Bitmap->LoadFromFile(fullPathSkill);
			TintNoTransparent(skillImage->Bitmap, skill.color);
		}
	}
}

//---------------------------------------------------------------------------
void TDohyoForm::DohyoSetup(){
	UpdateDohyoGUI(globalFighter1, globalFighter2, DohyoForm);
}
//---------------------------------------------------------------------------
void __fastcall TDohyoForm::ButtonReturnBanzukeClick(TObject *Sender)
{
	BanzukeForm->Show();
	this->Hide();
}
//---------------------------------------------------------------------------
void __fastcall TDohyoForm::ButtonReturnStreetClick(TObject *Sender)
{
	MainStreet->Show();
	this->Hide();
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
__fastcall TDohyoForm::TDohyoForm(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonWeight1Click(TObject *Sender)
{
	if (globalFighter1->owner == "P1" && globalFighter2->owner != "P1") {
		fighter1SkillValue = globalFighter1->weight;
		fighter1Tactic = "Weight";
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonEndurance1Click(TObject *Sender)
{
	if (globalFighter1->owner == "P1" && globalFighter2->owner != "P1") {
		fighter1SkillValue = globalFighter1->endurance;
		fighter1Tactic = "Endurance";
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonTechnique1Click(TObject *Sender)
{
	if (globalFighter1->owner == "P1" && globalFighter2->owner != "P1") {
		fighter1SkillValue = globalFighter1->technique;
		fighter1Tactic = "Technique";
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonSpeed1Click(TObject *Sender)
{
	if (globalFighter1->owner == "P1" && globalFighter2->owner != "P1") {
		fighter1SkillValue = globalFighter1->speed;
		fighter1Tactic = "Speed";
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonStrength1Click(TObject *Sender)
{
	if (globalFighter1->owner == "P1" && globalFighter2->owner != "P1") {
		fighter1SkillValue = globalFighter1->strength;
		fighter1Tactic = "Strength";
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonWeight2Click(TObject *Sender)
{
	if (globalFighter2->owner == "P1" && globalFighter1->owner != "P1") {
		fighter2SkillValue = globalFighter2->weight;
		fighter2Tactic = "Weight";
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonEndurance2Click(TObject *Sender)
{
	if (globalFighter2->owner == "P1" && globalFighter1->owner != "P1") {
		fighter2SkillValue = globalFighter2->endurance;
		fighter2Tactic = "Endurance";
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonTechnique2Click(TObject *Sender)
{
	if (globalFighter2->owner == "P1" && globalFighter1->owner != "P1") {
		fighter2SkillValue = globalFighter2->technique;
		fighter2Tactic = "Technique";
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonSpeed2Click(TObject *Sender)
{
	if (globalFighter2->owner == "P1" && globalFighter1->owner != "P1") {
		fighter2SkillValue = globalFighter2->speed;
		fighter2Tactic = "Speed";
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonStrength2Click(TObject *Sender)
{
	if (globalFighter2->owner == "P1" && globalFighter1->owner != "P1") {
		fighter2SkillValue = globalFighter2->strength;
		fighter2Tactic = "Strength";
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
	}
	else if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
		RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		ShowMessage("You own both Rikishi!");
	}
	else {
		ShowMessage("You do not own this Rikishi!");
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonFightClick(TObject *Sender)
{
	bool BeginFight = false;

	// Ask the player if they want to see training results
	TDialogService::MessageDialog("Begin the bout?!?! Are you sure?",
		TMsgDlgType::mtConfirmation, TMsgDlgButtons() << TMsgDlgBtn::mbYes << TMsgDlgBtn::mbNo,
		TMsgDlgBtn::mbNo, 0,
		[&BeginFight](const TModalResult AResult) {
			BeginFight = (AResult == mrYes);
		});

	if (isBanzukeComplete == false && isTrainingComplete == true) {
//		PopulateLeaderboardGrid();
		AssignFightersFromGrid();

		if (fighter1Tactic.empty()) {
			ShowMessage(AnsiString("Random Skill and Tactic Selected! (" + AnsiString(globalFighter1->name.c_str()) + ")"));
			RandomSkillForFighter(*globalFighter1, fighter1Tactic);
		}
		if (fighter2Tactic.empty()) {
			ShowMessage(AnsiString("Random Skill and Tactic Selected! (" + AnsiString(globalFighter2->name.c_str()) + ")"));
			RandomSkillForFighter(*globalFighter2, fighter2Tactic);
		}

		GetBoutTactic();
		FighterSkillValue(*globalFighter1, fighter1SkillValue);
		FighterSkillValue(*globalFighter2, fighter2SkillValue);

		fighter1Total = fighter1SkillValue;
		HandleInjury(*globalFighter1, fighter1Total);

		fighter2Total = fighter2SkillValue;
		HandleInjury(*globalFighter2, fighter2Total);

		if (globalFighter1->spirit == 4) {
			fighter1Total += 1;
		}
		if (globalFighter2->spirit == 4) {
			fighter2Total += 1;
		}

		if (currentBoutIndex >= 42 && currentBoutIndex < 49) {
			if (globalFighter1->wins == 3 && globalFighter1->losses == 3) {
				fighter1Total += 1;
			}
			if (globalFighter2->wins == 3 && globalFighter2->losses == 3) {
				fighter2Total += 1;
			}
		}

		if (fighter1Total > fighter2Total) {
			Victory(0, players);
		} else if (fighter1Total < fighter2Total) {
			Victory(1, players);
		} else {
			if (globalFighter1->weight > globalFighter2->weight) {
				Victory(0, players);
			} else if (globalFighter1->weight < globalFighter2->weight) {
				Victory(1, players);
			} else {
				if (globalFighter1->technique > globalFighter2->technique) {
					Victory(0, players);
				} else if (globalFighter1->technique < globalFighter2->technique) {
					Victory(1, players);
				} else {
					int winner = std::rand() % 2;
					Victory(winner, players);
				}
			}
		}

		SetBoutResult(currentBoutIndex, winnerIdx, loserIdx);
		UpdateDohyoGUI(globalFighter1, globalFighter2, DohyoForm);
//		UpdateTournamentGrid();
//		UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);
		Application->ProcessMessages();
//		ShowMessage(IntToStr(currentBoutIndex));
		currentBoutIndex++;
		AssignFightersFromGrid();
//		BanzukeForm->MemoBoutLog->Lines->Add("Battle over ...");
//		UpdateTournamentGrid();
//		UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);
		UpdateDohyoGUI(globalFighter1, globalFighter2, DohyoForm);
		Application->ProcessMessages();
		fighter1SkillValue = 0;
		fighter2SkillValue = 0;
		fighter1Tactic = "";
		fighter2Tactic = "";
	}

	if (currentBoutIndex == 49) {
//		BanzukeForm->MemoBoutLog->Lines->Add("The fighting has finished.");
		EndBanzuke();
	}
}
//---------------------------------------------------------------------------

void AssignFightersFromGrid()
{
//    for (const Rikishi& r : rikishiVector) {
//		ShowMessage("Rikishi: " + AnsiString(r.name.c_str()) + " with rank '" + AnsiString(r.rank.c_str()) + "'");
//	}

	if (currentBoutIndex >= 7 * 7) { // 7 days * 7 bouts per day
		ShowMessage("The Tournament is complete!");
		return;
	}

	int day = currentBoutIndex / 7;  // Get the current day (column)
	int bout = currentBoutIndex % 7; // Get the current bout (row)

	// Get the bout text from the grid
//	AnsiString boutText = BanzukeForm->StringGridTournament->Cells[day][bout];

	// Extract the two rank strings from the bout text
	std::string boutStr = boutText.c_str();
	size_t vsPos = boutStr.find(" / ");
	if (vsPos == std::string::npos) {
		ShowMessage("Error: Invalid bout format.");
		return;
	}

	std::string shortRank1 = boutStr.substr(0, vsPos);
	std::string shortRank2 = boutStr.substr(vsPos + 3); // Skip " / "

	// Convert short ranks to long-form ranks
	std::string longRank1, longRank2;
	std::unordered_map<std::string, std::string> rankMap = {
        {"Y", "Yokozuna"}, {"O", "Ozeki"}, {"S", "Sekiwake"}, {"K", "Komusubi"},
        {"M1", "Maegashira 1"}, {"M2", "Maegashira 2"}, {"M3", "Maegashira 3"},
		{"M4", "Maegashira 4"}, {"M5", "Maegashira 5"}, {"M6", "Maegashira 6"},
        {"M7", "Maegashira 7"}, {"M8", "Maegashira 8"}, {"M9", "Maegashira 9"},
        {"M10", "Maegashira 10"}, {"J1", "Juryo 1"}, {"J2", "Juryo 2"}
    };

	auto it1 = rankMap.find(shortRank1);
	auto it2 = rankMap.find(shortRank2);
	if (it1 != rankMap.end()) longRank1 = it1->second;
	if (it2 != rankMap.end()) longRank2 = it2->second;

	if (longRank1.empty() || longRank2.empty()) {
		ShowMessage("Error: Invalid rank abbreviation in bout.");
		ShowMessage(AnsiString(longRank1.c_str()));
		ShowMessage(AnsiString(longRank2.c_str()));
		ShowMessage(AnsiString(shortRank1.c_str()));
		ShowMessage(AnsiString(shortRank2.c_str()));
		return;
	}

	// Find the Rikishi with the corresponding ranks
	Rikishi* ptrFighter1 = nullptr;
	Rikishi* ptrFighter2 = nullptr;

    for (Rikishi& r : rikishiVector) {
        if (r.rank == longRank1 && ptrFighter1 == nullptr) {
			ptrFighter1 = &r;
        } else if (r.rank == longRank2 && ptrFighter2 == nullptr) {
            ptrFighter2 = &r;
        }

        if (ptrFighter1 && ptrFighter2) {
			break; // Found both fighters, exit loop
        }
	}

	if (!ptrFighter1 || !ptrFighter2) {
		ShowMessage("Error: Fighters not found for ranks " + AnsiString(longRank1.c_str()) + " and " + AnsiString(longRank2.c_str()));
        return;
    }

	// Convert pointers to references
	Rikishi& fighter1 = *ptrFighter1;
    Rikishi& fighter2 = *ptrFighter2;

	if (fighter1.name.empty()) {
		ShowMessage("fighter1 is nullptr during AssignFightersFromGrid");
	}
	if (fighter2.name.empty()) {
		ShowMessage("fighter2 is nullptr during AssignFightersFromGrid");
	}

	globalFighter1 = nullptr;
	globalFighter2 = nullptr;
	globalFighter1 = ptrFighter1;
	globalFighter2 = ptrFighter2;

	// Now you can use fighter1 and fighter2 directly
//	UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);

	// Update UI with fighter names
//	BanzukeForm->EditFighter1->Text = AnsiString(globalFighter1->name.c_str()) + " (" + AnsiString(globalFighter1->owner.c_str()) + ")";
//	BanzukeForm->EditFighter2->Text = AnsiString(globalFighter2->name.c_str()) + " (" + AnsiString(globalFighter2->owner.c_str()) + ")";

}


void RandomSkillForFighter(Rikishi& fighter, std::string& fighterTactic) {
	// Define skill choices as strings only
	const std::vector<std::string> skills = {
		"Strength", "Weight", "Technique", "Endurance", "Speed"
	};

	static std::random_device rd;
	static std::mt19937 gen(rd());
	std::uniform_int_distribution<int> dis(1, 6); // 1-6 roll

	int roll = dis(gen);
	if (roll <= 2) { // 1/3 chance for preferred skill
		fighterTactic = fighter.preferredSkill;
	} else { // 1/6 chance for each of the remaining skills
		// Adjust roll to pick one of the 4 remaining skills
        int remainingRoll = dis(gen) % 4;
		int count = 0;
		for (const auto& skill : skills) {
			if (skill != fighter.preferredSkill) {
				if (count == remainingRoll) {
					fighterTactic = skill;
					break;
				}
				count++;
			}
		}
	}

	if (fighterTactic.empty()) {
		ShowMessage("Something went wrong!");
		fighterTactic = skills[std::rand() % skills.size()];
	}
}

void GetBoutTactic() {
	// If both players choose the same tactic, use that
	if (fighter1Tactic == fighter2Tactic) {
		boutTactic = fighter1Tactic;
	} else {
		// Define tactic dominance rules
		static const std::unordered_map<std::string, std::unordered_set<std::string>> tacticWins = {
			{"Strength", {"Weight", "Technique"}},
			{"Speed", {"Strength", "Endurance"}},
			{"Technique", {"Weight", "Speed"}},
			{"Endurance", {"Strength", "Technique"}},
			{"Weight", {"Endurance", "Speed"}}
		};

		auto it1 = tacticWins.find(fighter1Tactic);
		auto it2 = tacticWins.find(fighter2Tactic);

		if (it1 != tacticWins.end() && it1->second.count(fighter2Tactic)) {
			boutTactic = fighter1Tactic;
		} else if (it2 != tacticWins.end() && it2->second.count(fighter1Tactic)) {
			boutTactic = fighter2Tactic;
		} else {
			boutTactic = "Unknown";
		}
	}

	// Log the bout tactic
//    MainStreet->MemoLog->Lines->Add("The bout tactic is " + boutTactic + "!");
}

void FighterSkillValue(Rikishi& fighter, int& fighterSkillValue) {
	if (boutTactic == "Strength") {
		fighterSkillValue = fighter.strength; // Replace with actual value
	} else if (boutTactic == "Weight") {
		fighterSkillValue = fighter.weight; // Replace with actual value
	} else if (boutTactic == "Technique") {
		fighterSkillValue = fighter.technique; // Replace with actual value
	} else if (boutTactic == "Endurance") {
		fighterSkillValue = fighter.endurance; // Replace with actual value
	} else if (boutTactic == "Speed") {
		fighterSkillValue = fighter.speed; // Replace with actual value
	} else {
		fighterSkillValue = 0; // Default if no valid skill
		ShowMessage("Error: Invalid skill detected.");
	}
}//
//
void HandleInjury(Rikishi& fighter, int& fighterTotal) {
	// Perform luck roll (0-6)
	Luck = std::rand() % 7;

    // Output the luck roll value
//	MainStreet->MemoLog->Lines->Add(fighter.name + " rolled a " + std::to_string(Luck) + " on the luck die.");

	// Add luck roll value to fighterTotal (you can adjust this logic as per your needs)
	fighterTotal += Luck;

	// Now, handle the injury part (same as before)
	if (Luck == 1) {
        // Randomly choose one of the 5 skills (strength, weight, endurance, technique, speed)
        int skillRoll = std::rand() % 5;
        std::string selectedSkill;
        bool injuryOccurred = false;

		// Determine which skill was selected
        switch (skillRoll) {
			case 0: selectedSkill = "Strength"; break;
			case 1: selectedSkill = "Weight"; break;
            case 2: selectedSkill = "Endurance"; break;
			case 3: selectedSkill = "Technique"; break;
			case 4: selectedSkill = "Speed"; break;
		}

		// Check if the selected skill is one that can cause injury (Endurance, Strength, Speed)
		if (selectedSkill == "Endurance" && !fighter.isInjuredEndurance) {
            fighter.isInjuredEndurance = true;
			injuryOccurred = true;
		} else if (selectedSkill == "Strength" && !fighter.isInjuredStrength) {
            fighter.isInjuredStrength = true;
            injuryOccurred = true;
        } else if (selectedSkill == "Speed" && !fighter.isInjuredSpeed) {
			fighter.isInjuredSpeed = true;
            injuryOccurred = true;
        }

        // If the injury bool is already true, the fighter gets a major injury
        if (injuryOccurred) {
            // Reduce the skill by 1
			if (selectedSkill == "Strength") {
				if (fighter.strength > 0) {
					fighter.strength--;
				}
				else {
					if (fighter.strengthLimit > 0) {
						fighter.strengthLimit--;
					}
					else {
						fighter.strength = 0;
					}
				}
			} else if (selectedSkill == "Endurance") {
				if (fighter.endurance > 0) {
					fighter.endurance--;
				}
				else {
					if (fighter.enduranceLimit > 0) {
						fighter.enduranceLimit--;
					}
					else {
						fighter.endurance = 0;
					}
				}
			} else if (selectedSkill == "Speed") {
				if (fighter.speed > 0) {
					fighter.speed--;
				}
				else {
					if (fighter.speed > 0) {
						fighter.speed--;
					}
					else {
						fighter.speed = 0;
					}
				}
			}

			// Log injury outcome
//            MainStreet->MemoLog->Lines->Add(fighter.name + " selected skill: " + selectedSkill + ". Injury status: " + (injuryOccurred ? "Injured" : "Not Injured"));
		}
	}
}



void __fastcall TDohyoForm::ButtonNextPlayerBoutClick(TObject *Sender)
{

//	PopulateLeaderboardGrid();

	for (int i = 0; i < 49; i++) {
		UpdateDohyoGUI(globalFighter1, globalFighter2, DohyoForm);
		if (isBanzukeComplete == false && isTrainingComplete == true && currentBoutIndex != 49) {


			AssignFightersFromGrid();

			if (globalFighter1->owner == "P1" && globalFighter2->owner == "P1") {
//				ShowMessage("Both sumo are owned by the same player, automatically resolving the bout!");
			}
			else if (globalFighter1->owner == "P1" || globalFighter2->owner == "P1") {
				ShowMessage("The current bout features one of your sumo! Get ready for battle!");
				break;
			}
			else {
//				ShowMessage("Neither sumo are owned by the same player, automatically resolving the bout!");
			}

			RandomSkillForFighter(*globalFighter1, fighter1Tactic);
			RandomSkillForFighter(*globalFighter2, fighter2Tactic);

			GetBoutTactic();
			FighterSkillValue(*globalFighter1, fighter1SkillValue);
			FighterSkillValue(*globalFighter2, fighter2SkillValue);

			fighter1Total = fighter1SkillValue;
			HandleInjury(*globalFighter1, fighter1Total);

			fighter2Total = fighter2SkillValue;
			HandleInjury(*globalFighter2, fighter2Total);

			if (globalFighter1->spirit == 4) {
				fighter1Total += 1;
			}
			if (globalFighter2->spirit == 4) {
				fighter2Total += 1;
			}

			if (currentBoutIndex >= 42 && currentBoutIndex < 49) {
				if (globalFighter1->wins == 3 && globalFighter1->losses == 3) {
					fighter1Total += 1;
				}
				if (globalFighter2->wins == 3 && globalFighter2->losses == 3) {
					fighter2Total += 1;
				}
			}

			if (fighter1Total > fighter2Total) {
				Victory(0, players);
			} else if (fighter1Total < fighter2Total) {
				Victory(1, players);
			} else {
				if (globalFighter1->weight > globalFighter2->weight) {
					Victory(0, players);
				} else if (globalFighter1->weight < globalFighter2->weight) {
					Victory(1, players);
				} else {
					if (globalFighter1->technique > globalFighter2->technique) {
						Victory(0, players);
					} else if (globalFighter1->technique < globalFighter2->technique) {
						Victory(1, players);
					} else {
						int winner = std::rand() % 2;
						Victory(winner, players);
					}
				}
			}

//			PopulateLeaderboardGrid();
			SetBoutResult(currentBoutIndex, winnerIdx, loserIdx);
//			UpdateTournamentGrid();
//			UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);
			Application->ProcessMessages();
			currentBoutIndex++;
			AssignFightersFromGrid();
//			BanzukeForm->MemoBoutLog->Lines->Add("Battle over ...");
//			UpdateTournamentGrid();
//			PopulateLeaderboardGrid();
			if (currentBoutIndex == 49) {
//				BanzukeForm->MemoBoutLog->Lines->Add("The fighting has finished.");
//				PopulateLeaderboardGrid();
				EndBanzuke();
				break;
			}

		}
		else if (currentBoutIndex == 49) {
//			BanzukeForm->MemoBoutLog->Lines->Add("The fighting has finished.");
//			PopulateLeaderboardGrid();
			EndBanzuke();
			break;
		}
		else {
			ShowMessage("The training phase is not complete. The sumo are not ready.");
            break;
		}
	}
}
//---------------------------------------------------------------------------

void __fastcall TDohyoForm::ButtonDohyoClick(TObject *Sender)
{
	SetupBattle();
	BattleForm->Show();
	this->Hide();
}
//---------------------------------------------------------------------------


void TBanzukeForm::StartBanzuke() {
	isBanzukeComplete = false;  // Reset the Banzuke status
	currentBoutIndex = 0;    // Start from the first Rikishi
//	UpdateTournamentGrid();
	AssignFightersFromGrid();
//	TImage* imagevs = dynamic_cast<TImage*>(BanzukeForm->FindComponent("ImageVS"));
//	AnsiString fullPathVS = VSPath;
//	ImageVS->Bitmap->LoadFromFile(fullPathVS);
//	PopulateLeaderboardGrid();
}

// Function to end the Banzuke phase
void EndBanzuke() {
	isBanzukeComplete = true;  // Mark Banzuke as complete
	ShowMessage("Ending Banzuke Phase...");
	BanzukePhaseComplete();    // Call the function to complete the Banzuke phase in MainStreet.cpp
//	UpdateBanzukeGrid();
}
//---------------------------------------------------------------------------

void Victory(int winner, std::vector<Player>& players) {
	if (winner == 0) {
		globalFighter1->wins += 1;
		globalFighter2->losses += 1;

		if (globalFighter1->isShaken) {
			globalFighter1->isShaken = false;
		}

		// Check if fighter1 is M1-M10 and defeated a Yokozuna or Ozeki
		if ((globalFighter1->rank.find("Maegashira") != std::string::npos) &&
			(globalFighter2->rank == "Yokozuna" || globalFighter2->rank == "Ozeki")) {

			if (globalFighter1->spirit < 4) {
				globalFighter1->spirit += 1;
			}

			// Award VP to the player who owns fighter1
			for (auto& player : players) {
				if (player.name == globalFighter1->owner) {
					player.VP += 1;
					break;
				}
			}
		}

		if (globalFighter2->isShaken) {
			if (globalFighter2->spirit > 0) {
				globalFighter2->spirit -= 1;
			}
            globalFighter2->isShaken = false;
		} else {
            globalFighter2->isShaken = true;
		}
	}
	else if (winner == 1) {
		globalFighter2->wins += 1;
		globalFighter1->losses += 1;

		if (globalFighter2->isShaken) {
			globalFighter2->isShaken = false;
		}

		// Check if fighter2 is M1-M10 and defeated a Yokozuna or Ozeki
		if ((globalFighter2->rank.find("Maegashira") != std::string::npos) &&
			(globalFighter1->rank == "Yokozuna" || globalFighter1->rank == "Ozeki")) {

			if (globalFighter2->spirit < 4) {
				globalFighter2->spirit += 1;
			}

			// Award VP to the player who owns fighter2
			for (auto& player : players) {
				if (player.name == globalFighter2->owner) {
					player.VP += 1;
                    break;
				}
			}
		}

		if (globalFighter1->isShaken) {
			if (globalFighter1->spirit > 0) {
				globalFighter1->spirit -= 1;
			}
            globalFighter1->isShaken = false;
		} else {
			globalFighter1->isShaken = true;
		}
	}
	else {
		ShowMessage("Error: Invalid winner input.");
	}
}
//---------------------------------------------------------------------------


