#include <System.UITypes.hpp> // For TAlphaColor
#include <FMX.Graphics.hpp>   // For TBitmap
#include <fmx.h>
#include <FMX.DialogService.hpp> // Required for TDialogService
#include <System.SysUtils.hpp>  // Required for UnicodeString conversion
#include <regex>
#include <vector>
#include <random>
#include <FMX.Forms.hpp>
#include <FMX.Memo.hpp>
#include <FMX.Layouts.hpp>
#include <iostream>
#include <FMX.ScrollBox.hpp>
//---------------------------------------------------------------------------
#include "Beya.h"
#include "Street.h" // Include after Beya.h
#include "Noboru.h" // Include after Beya.h to avoid issues
//#include "Training.h" // Include after Beya.h to avoid issues
#include "Banzuke.h"
//---------------------------------------------------------------------------
#pragma hdrstop
#pragma package(smart_init)
#pragma resource "*.fmx"
//---------------------------------------------------------------------------
TYourBeya *YourBeya;

int TrainingCost;
int cost1, cost2, cost3;
int SkillTracker[3];
int WeightTracker1 = 0;
int EnduranceTracker1 = 0;
int TechniqueTracker1 = 0;
int SpeedTracker1 = 0;
int StrengthTracker1 = 0;
int SkillTracker2 = 0;
int WeightTracker2 = 0;
int EnduranceTracker2 = 0;
int TechniqueTracker2 = 0;
int SpeedTracker2 = 0;
int StrengthTracker2 = 0;
int SkillTracker3 = 0;
int WeightTracker3 = 0;
int EnduranceTracker3 = 0;
int TechniqueTracker3 = 0;
int SpeedTracker3 = 0;
int StrengthTracker3 = 0;
String skillstring;
String coststring;
bool UpgradeOk = true;
bool showResults = false;

String DoorPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\Door2.png";
String ImagesPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\";
String SkillPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\SkillToken_";
//String RikishiPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\Sumo";
//String BeltPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\SumoBelt";
//String YokozunaPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\SumoYokozunaBelt";
//---------------------------------------------------------------------------

bool isTrainingComplete = false;  // Flag to track if training is complete
bool IsTrainingComplete() {
	return isTrainingComplete;
}
void TrainingPhaseComplete();

int WhichRikishi;

Rikishi* firstPlayerRikishi = nullptr;  // Pointer to the first owned Rikishi
Rikishi* secondPlayerRikishi = nullptr;  // Pointer to the first owned Rikishi
Rikishi* thirdPlayerRikishi = nullptr;  // Pointer to the first owned Rikishi

//int UpgradePoints;

int StrengthTracker[3] = {0, 0, 0};
int WeightTracker[3] = {0, 0, 0};
int EnduranceTracker[3] = {0, 0, 0};
int TechniqueTracker[3] = {0, 0, 0};
int SpeedTracker[3] = {0, 0, 0};
int SpiritTracker[3] = {0, 0, 0};

__fastcall TYourBeya::TYourBeya(TComponent* Owner) : TForm(Owner)
{
}

std::vector<std::reference_wrapper<Rikishi>> GetPlayerOwnedRikishi(std::vector<Rikishi>& rikishiVector, const std::string& owner) {
	std::vector<std::reference_wrapper<Rikishi>> rikishiOwnedByPlayer;
	for (Rikishi& rikishi : rikishiVector) {
		if (rikishi.owner == owner) {
			rikishiOwnedByPlayer.push_back(rikishi);
		}
	}
	return rikishiOwnedByPlayer;
}

// Helper function to apply a tint to a pixel
TAlphaColor ApplyTintToPixel(TAlphaColor originalColor, TAlphaColor tintColor) {
	// Extract RGB components from the original color
    uint8_t r = (originalColor >> 16) & 0xFF;
    uint8_t g = (originalColor >> 8) & 0xFF;
    uint8_t b = (originalColor >> 0) & 0xFF;

    // Extract RGB components from the tint color
    uint8_t tr = (tintColor >> 16) & 0xFF;
    uint8_t tg = (tintColor >> 8) & 0xFF;
    uint8_t tb = (tintColor >> 0) & 0xFF;

    // Simple blend of the original color with the tint (adjust as needed)
    r = (r + tr) / 2;
    g = (g + tg) / 2;
    b = (b + tb) / 2;

    // Recreate the tinted color and return it
    return (originalColor & 0xFF000000) | (r << 16) | (g << 8) | b;
}

// Function to apply tint to non-transparent pixels of the bitmap
void TintNonTransparent(TBitmap* bitmap, TAlphaColor tintColor) {
    if (!bitmap || bitmap->IsEmpty()) return;

    // Lock the bitmap data to access pixels
    TBitmapData bitmapData;
	if (bitmap->Map(TMapAccess::ReadWrite, bitmapData)) {  // Correct enum value for access
        // Iterate through each pixel
		for (int y = 0; y < bitmap->Height; ++y) {
            for (int x = 0; x < bitmap->Width; ++x) {
                // Get the color of the current pixel
                TAlphaColor pixelColor = bitmapData.GetPixel(x, y);
				uint8_t alpha = (pixelColor >> 24) & 0xFF;  // Extract alpha component

				// If the pixel is not transparent, apply the tint
                if (alpha > 0) {
                    TAlphaColor tintedPixel = ApplyTintToPixel(pixelColor, tintColor);
					bitmapData.SetPixel(x, y, tintedPixel); // Set the tinted pixel
                }
			}
        }
		// Unlock the bitmap after modifications
        bitmap->Unmap(bitmapData);
	}
}


void ResetPlayerRikishi() {

	firstPlayerRikishi = nullptr;  // Pointer to the first owned Rikishi
	secondPlayerRikishi = nullptr;  // Pointer to the first owned Rikishi
	thirdPlayerRikishi = nullptr;  // Pointer to the first owned Rikishi

	for (Rikishi& rikishi : rikishiVector) {
		if (rikishi.owner == "P1") { // Ensure we update max 3 rikishi
			if (!firstPlayerRikishi) {
				firstPlayerRikishi = &rikishi;  // Store the first found Rikishi
			}
			else if (!secondPlayerRikishi) {
				secondPlayerRikishi = &rikishi;  // Store the second found Rikishi
			}
			else if (!thirdPlayerRikishi) {
				thirdPlayerRikishi = &rikishi;  // Store the third found Rikishi
			}
		}
	}
}

void UpdatePlayerRikishiList(std::vector<Rikishi>& rikishiVector, std::vector<Player>& players) {
	for (auto& player : players) {
		for (auto& rikishi : player.rikishiList) {
            // Find the matching Rikishi in rikishiVector
			auto it = std::find_if(rikishiVector.begin(), rikishiVector.end(),
                [&](const Rikishi& r) { return r.name == rikishi.name; });

            // If found, update the Rikishi in rikishiList
            if (it != rikishiVector.end()) {
                rikishi = *it;  // Copy updated values
            }
        }
    }
}

void TYourBeya::UpdateBeya() {

    UpdatePlayerRikishiList(rikishiVector, players);

    int rikishiIndex = 1; // Start from the first UI slot
	int P1_rikishiCount = 0;

    // Find P1
    auto it = std::find_if(players.begin(), players.end(), [](const Player& p) {
        return p.name == "P1";
    });

    if (it == players.end()) return;  // Exit if P1 not found
    Player& P1 = *it;
    P1_rikishiCount = P1.rikishiList.size();

    // Update the Doors
    std::vector<std::string> doorNames = {"ImageDoor3", "ImageDoor2", "ImageDoor1"};
    for (int i = 0; i < 3; i++) {
        TImage* imageDoor = dynamic_cast<TImage*>(YourBeya->FindComponent(doorNames[i].c_str()));
        if (imageDoor) {
            imageDoor->Visible = (P1_rikishiCount < (3 - i));
			if (imageDoor->Visible) imageDoor->Bitmap->LoadFromFile(DoorPath);
        }
    }

    // Update Rikishi UI (Only from P1's rikishiList)
    for (Rikishi& rikishi : P1.rikishiList) {
        if (rikishiIndex > 3) break; // Limit UI to 3 rikishi

        // Update rank, name, and age
        TEdit* editRank = dynamic_cast<TEdit*>(YourBeya->FindComponent("EditRank" + IntToStr(rikishiIndex)));
        TEdit* editName = dynamic_cast<TEdit*>(YourBeya->FindComponent("EditName" + IntToStr(rikishiIndex)));
        TEdit* editAge = dynamic_cast<TEdit*>(YourBeya->FindComponent("EditAge" + IntToStr(rikishiIndex)));
        if (editRank) editRank->Text = "Rank: " + AnsiString(rikishi.rank.c_str());
        if (editName) editName->Text = AnsiString(rikishi.name.c_str());
        if (editAge) editAge->Text = "Age: " + AnsiString(std::to_string(rikishi.age).c_str());

        // Load Rikishi image
        TImage* imageRikishi = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageRikishi" + IntToStr(rikishiIndex)));
        if (imageRikishi) {
            AnsiString fullPathRikishi = RikishiPath + IntToStr(rikishi.spirit) + ".png";
            imageRikishi->Bitmap->LoadFromFile(fullPathRikishi);
        }
		TImage* imagebed = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageBed" + IntToStr(rikishiIndex)));
		if (imagebed) {
			AnsiString fullPathBed = ImagesPath + "Bed.png";
			imagebed->Bitmap->LoadFromFile(fullPathBed);
		}
		TImage* imageshelf = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageShelf" + IntToStr(rikishiIndex)));
		if (imageshelf) {
			AnsiString fullPathShelve = ImagesPath + "Shelf.png";
			imageshelf->Bitmap->LoadFromFile(fullPathShelve);
		}

		std::string randomstring = rikishi.RandomString;

		TImage* imageposter = dynamic_cast<TImage*>(YourBeya->FindComponent("ImagePoster" + IntToStr(rikishiIndex)));
		if (imageposter) {
			AnsiString fullPathPoster = ImagesPath + "Poster" + randomstring.c_str() + ".png";
			imageposter->Bitmap->LoadFromFile(fullPathPoster);
		}
		// Load Belt image and apply color
		TImage* imageBelt = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageBelt" + IntToStr(rikishiIndex)));
		if (imageBelt) {
			AnsiString fullPathBelt = BeltPath + ".png";
			imageBelt->Bitmap->LoadFromFile(fullPathBelt);

			// Convert UnicodeString to std::string
			std::string colorStr = AnsiString(rikishi.colour).c_str();
			std::smatch match;
			std::regex numRegex(R"(\d+)");
			if (std::regex_search(colorStr, match, numRegex)) {
				UnicodeString extractedNumber = UnicodeString(match.str().c_str());
				TAlphaColor color = (TAlphaColor) StrToUInt(extractedNumber);
				TintNonTransparent(imageBelt->Bitmap, color);
			} else {
				ShowMessage("Invalid color format: " + rikishi.colour);
			}
		}

		// If Yokozuna, load the Yokozuna image
		if (rikishi.rank == "Yokozuna") {
			TImage* imageYokozuna = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageYokozuna" + IntToStr(rikishiIndex)));
			if (imageYokozuna) {
				AnsiString fullPathYokozuna = YokozunaPath + ".png";
				imageYokozuna->Bitmap->LoadFromFile(fullPathYokozuna);
				imageYokozuna->Opacity = 1.0;  // Fully visible
			}
		} else {
			TImage* imageYokozuna = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageYokozuna" + IntToStr(rikishiIndex)));
			if (imageYokozuna) {
				imageYokozuna->Opacity = 0.0;  // Invisible but still clickable
			}
		}


		// Load and tint skill images
		struct Skill {
			const char* name;
			int value;
			int limit;
			TAlphaColor color;
		};

		Skill skills[] = {
			{"Weight", rikishi.weight, rikishi.weightLimit, TAlphaColorRec::Black},
			{"Endurance", rikishi.endurance, rikishi.enduranceLimit, (TAlphaColor)0xFF00FF00},
			{"Technique", rikishi.technique, rikishi.techniqueLimit, TAlphaColorRec::Blue},
			{"Speed", rikishi.speed, rikishi.speedLimit, TAlphaColorRec::Yellow},
			{"Strength", rikishi.strength, rikishi.strengthLimit, TAlphaColorRec::Red}
		};

		for (const Skill& skill : skills) {
			TImage* skillImage = dynamic_cast<TImage*>(YourBeya->FindComponent("Image" + AnsiString(skill.name) + IntToStr(rikishiIndex)));
			if (skillImage) {
				AnsiString fullPathSkill = SkillPath + IntToStr(skill.value) + IntToStr(skill.limit) + ".png";
				skillImage->Bitmap->LoadFromFile(fullPathSkill);
				TintNonTransparent(skillImage->Bitmap, skill.color);
			}
		}
		rikishiIndex++; // Move to next UI slot
	}

	// Clear remaining UI slots if rikishi retired
	for (int i = rikishiIndex; i <= 3; i++) {
		TEdit* editRank = dynamic_cast<TEdit*>(YourBeya->FindComponent("EditRank" + IntToStr(i)));
		TEdit* editName = dynamic_cast<TEdit*>(YourBeya->FindComponent("EditName" + IntToStr(i)));
		TEdit* editAge = dynamic_cast<TEdit*>(YourBeya->FindComponent("EditAge" + IntToStr(i)));
		TImage* imageRikishi = dynamic_cast<TImage*>(YourBeya->FindComponent("ImageRikishi" + IntToStr(i)));

		if (editRank) editRank->Text = "";
        if (editName) editName->Text = "";
        if (editAge) editAge->Text = "";
        if (imageRikishi) imageRikishi->Bitmap->Clear(TAlphaColorRec::Null);
    }
}

// Function to generate a random number in a given range
int RollDice(int min, int max) {
	static std::random_device rd;
	static std::mt19937 gen(rd());
	std::uniform_int_distribution<int> dist(min, max);
	return dist(gen);
}

// Function to train CPU-controlled Rikishi
void TrainCPUrikishi(std::vector<Rikishi>& rikishiVector) {
    bool showResults = false;

	// Ask the player if they want to see training results
	TDialogService::MessageDialog("Would you like to see the training results from the CPU Rikishi?",
		TMsgDlgType::mtConfirmation, TMsgDlgButtons() << TMsgDlgBtn::mbYes << TMsgDlgBtn::mbNo,
		TMsgDlgBtn::mbNo, 0,
		[&showResults](const TModalResult AResult) {
			showResults = (AResult == mrYes);
		});

    AnsiString resultsText = "";

    for (Rikishi& rikishi : rikishiVector) {
        std::vector<std::string> skillsIncreased;
        skillsIncreased.clear();

        if (rikishi.owner == "CPU") {
            int roll = RollDice(1, 6);
            int spiritIncrease = 0;
            int skillUpgrades = 0;

            // Adjust training results based on the age of the rikishi
            if (rikishi.age >= 21 && rikishi.age <= 26) {
                switch (roll) {
                    case 2: spiritIncrease = 1; break;
                    case 3: skillUpgrades = 1; break;
                    case 4: spiritIncrease = 2; break;
                    case 5: spiritIncrease = 1; skillUpgrades = 1; break;
                    case 6: spiritIncrease = 2; skillUpgrades = 2; break;
                }
            } else if (rikishi.age >= 27 && rikishi.age <= 30) {
                switch (roll) {
                    case 2: spiritIncrease = 1; break;
                    case 3: skillUpgrades = 1; break;
                    case 4: spiritIncrease = 1; skillUpgrades = 1; break;
                    case 5: skillUpgrades = 2; break;
                    case 6: spiritIncrease = 2; skillUpgrades = 2; break;
                }
            } else if (rikishi.age >= 31 && rikishi.age <= 33) {
                switch (roll) {
                    case 2: spiritIncrease = 1; break;
                    case 3: skillUpgrades = 1; break;
                    case 4: spiritIncrease = 1; break;
                    case 5: skillUpgrades = 1; break;
                    case 6: spiritIncrease = 1; skillUpgrades = 2; break;
                }
            } else {
                switch (roll) {
                    case 4: spiritIncrease = 1; break;
                    case 5: spiritIncrease = 1; break;
                    case 6: spiritIncrease = 2; break;
                }
            }

			// Apply spirit increase
			if (rikishi.spirit + spiritIncrease < 4) {
				 rikishi.spirit += spiritIncrease;
			}
			else if (rikishi.spirit + spiritIncrease >= 4) {
                 rikishi.spirit = 4;
			}


            // List of skill pointers for easy modification
            std::vector<std::pair<int*, int*>> skills = {
                {&rikishi.strength, &rikishi.strengthLimit},
                {&rikishi.weight, &rikishi.weightLimit},
                {&rikishi.technique, &rikishi.techniqueLimit},
                {&rikishi.endurance, &rikishi.enduranceLimit},
                {&rikishi.speed, &rikishi.speedLimit}
            };

            // Distribute skill upgrades randomly (lost if capped)
            for (int i = 0; i < skillUpgrades; i++) {
                int skillIndex = RollDice(0, skills.size() - 1);
                switch (skillIndex) {
                    case 0: skillsIncreased.push_back("Strength"); break;
                    case 1: skillsIncreased.push_back("Weight"); break;
                    case 2: skillsIncreased.push_back("Technique"); break;
                    case 3: skillsIncreased.push_back("Endurance"); break;
                    case 4: skillsIncreased.push_back("Speed"); break;
                }
                if (*skills[skillIndex].first < *skills[skillIndex].second) {
                    (*skills[skillIndex].first)++; // Increase skill if within limit
                }
            }

            // Prepare the result text if the user wants to see it
            if (showResults) {
				resultsText += "Rikishi: " + AnsiString(rikishi.name.c_str()) + "|";
				resultsText += "Age: " + IntToStr(rikishi.age) + "|";
				resultsText += "Rolled: " + IntToStr(roll) + "|";
				resultsText += "Received: " + IntToStr(spiritIncrease) + " Spirit|";
				resultsText += IntToStr(skillUpgrades) + " Skill Points|";

				if (!skillsIncreased.empty()) {
					resultsText += "Skills Increased: ";
					for (size_t i = 0; i < skillsIncreased.size(); ++i) {
						resultsText += skillsIncreased[i].c_str();
						if (i < skillsIncreased.size() - 1) {
							resultsText += ", ";
						}
					}
					resultsText += "|\n";
                }
//                resultsText += "\n";
            }
        }
    }

    // Show the results in a message dialog as a popup with the correct title
    if (showResults && !resultsText.IsEmpty()) {
        TDialogService::MessageDialog(
            "Computer Training Session Results:\n" + resultsText,
            TMsgDlgType::mtInformation,
            TMsgDlgButtons() << TMsgDlgBtn::mbOK,
            TMsgDlgBtn::mbOK, 0,
            [](const TModalResult AResult) {
                // Handle response if needed
            }
        );
    }
}

void PayTraining(int TrainingCost) {
	players[0].DeductAP(TrainingCost);    // Another thing that doesn't comply with multiplayer
	UpdatePoints();
}

void TYourBeya::UpgradeSkill(int rikishiIndex, String skillName) {
	auto rikishiOwnedByP1 = GetPlayerOwnedRikishi(rikishiVector, "P1");
	if (rikishiIndex >= rikishiOwnedByP1.size()) {
		ShowMessage("Player 1 does not have enough Rikishi.");
		return;
	}

	Rikishi& selectedRikishi = rikishiOwnedByP1[rikishiIndex].get();
	int* tracker = nullptr;
	int* stat = nullptr;
	int limit = 0;

	if (AnsiString(skillName) == "strength") {
		if (selectedRikishi.age > 33) {
			ShowMessage("The Rikishi is too old to train skills. Try raising their spirit.");
		}
		else {
			tracker = &StrengthTracker[rikishiIndex];
			stat = &selectedRikishi.strength;
			limit = selectedRikishi.strengthLimit;
		}
	} else if (AnsiString(skillName) == "weight") {
		if (selectedRikishi.age > 33) {
			ShowMessage("The Rikishi is too old to train skills. Try raising their spirit.");
		}
		else {
			tracker = &WeightTracker[rikishiIndex];
			stat = &selectedRikishi.weight;
			limit = selectedRikishi.weightLimit;
		}
	} else if (AnsiString(skillName) == "endurance") {
		if (selectedRikishi.age > 33) {
			ShowMessage("The Rikishi is too old to train skills. Try raising their spirit.");
		}
		else {
			tracker = &EnduranceTracker[rikishiIndex];
			stat = &selectedRikishi.endurance;
			limit = selectedRikishi.enduranceLimit;
		}
	} else if (AnsiString(skillName) == "technique") {
		if (selectedRikishi.age > 33) {
			ShowMessage("The Rikishi is too old to train skills. Try raising their spirit.");
		}
		else {
			tracker = &TechniqueTracker[rikishiIndex];
			stat = &selectedRikishi.technique;
			limit = selectedRikishi.techniqueLimit;
		}
	} else if (AnsiString(skillName) == "speed") {
		if (selectedRikishi.age > 33) {
			ShowMessage("The Rikishi is too old to train skills. Try raising their spirit.");
		}
		else {
			tracker = &SpeedTracker[rikishiIndex];
			stat = &selectedRikishi.speed;
			limit = selectedRikishi.speedLimit;
        }
	} else if (AnsiString(skillName) == "spirit") {
		tracker = &SpiritTracker[rikishiIndex];
		stat = &selectedRikishi.spirit;
		limit = 4;
	}

	if (*tracker == 0 && *stat < limit) {
		(*stat)++;
		if (SkillTracker[rikishiIndex] == 0) {
			PayTraining(cost1);
		}
		else if (SkillTracker[rikishiIndex] == 1) {
			PayTraining(cost2);
		}
		else if (SkillTracker[rikishiIndex] == 2) {
			PayTraining(cost3);
		}
		else {
			ShowMessage("Something went wrong with the tracker!");
		}

		SkillTracker[rikishiIndex]++;

		if (skillName != "Spirit") {
			(*tracker)++;
		}
		YourBeya->UpdateBeya();
//        UpdateBanzukeGrid();
	} else {
		ShowMessage("You cannot improve this skill any more this round of training.");
	}
}

// Function to start the training phase
void TYourBeya::StartTraining() {
	SkillTracker[0] = SkillTracker[1] = SkillTracker[2] = 0;
	isTrainingComplete = false;  // Reset the training status
}

void TYourBeya::CollectUpgradePoints(int UpgradePoints) {
	 ShowMessage("You have " + IntToStr(UpgradePoints) + " availble upgrades.");
}

//---------------------------------------------------------------------------

void __fastcall TYourBeya::ReturnStreetClick(TObject *Sender) {
	MainStreet->Show(); // Show the main form
	this->Hide();     // Hide the second form
}

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//// Fix for checking and creating TrainingPopup only once
//void __fastcall TYourBeya::TrainRikishi1Click(TObject *Sender) {
//	if (TrainedRikishi1) {
//		ShowMessage("You can already trained this rikishi.");
//	}
//	else if (isBiddingComplete == false) {
//		ShowMessage("Bidding is not complete, please complete the bidding before starting to train!");
//	}
//	else {
//
//		WhichRikishi = 1;
//
//		ResetPlayerRikishi();
//
//		// Ensure we are training the correct Rikishi
//		if (firstPlayerRikishi) {
//	//		ReceiveTrainingRikishi(firstPlayerRikishi);
//			TrainingPopup = new TTrainingPopup(this);
//			TrainingPopup->UpdateTrainingTable(firstPlayerRikishi);
//			TrainingPopup->Show(); // Show the Noboru form
//			this->Hide();       // Hide the current form
//		}
//		else {
//			ShowMessage("You have no rikishi to train. Bid to get control over new rikishi.");
//		}
//	}
//}
//
//// Repeated training functions adjusted similarly
//void __fastcall TYourBeya::TrainRikishi2Click(TObject *Sender) {
//	if (TrainedRikishi2) {
//		ShowMessage("You can already trained this rikishi.");
//	}
//	else if (isBiddingComplete == false) {
//		ShowMessage("Bidding is not complete, please complete the bidding before starting to train!");
//	}
//	else {
//		TrainedRikishi2 = true;
//		WhichRikishi = 2;
//
//		ResetPlayerRikishi();
//
//		// Ensure we are training the correct Rikishi
//		if (firstPlayerRikishi) {
//	//		ReceiveTrainingRikishi(firstPlayerRikishi);
//			TrainingPopup = new TTrainingPopup(this);
//			TrainingPopup->UpdateTrainingTable(secondPlayerRikishi);
//			TrainingPopup->Show(); // Show the Noboru form
//			this->Hide();       // Hide the current form
//		}
//		else {
//			ShowMessage("No Rikishi in second Beya slot. Try another.");
//		}
//	}
//}
//
//void __fastcall TYourBeya::TrainRikishi3Click(TObject *Sender) {
//	if (TrainedRikishi3) {
//		ShowMessage("You can already trained this rikishi.");
//	}
//	else if (isBiddingComplete == false) {
//		ShowMessage("Bidding is not complete, please complete the bidding before starting to train!");
//	}
//	else {
//		TrainedRikishi3 = true;
//		WhichRikishi = 3;
//
//		ResetPlayerRikishi();
//
//		// Ensure we are training the correct Rikishi
//		if (firstPlayerRikishi) {
//	//		ReceiveTrainingRikishi(firstPlayerRikishi);
//			TrainingPopup = new TTrainingPopup(this);
//			TrainingPopup->UpdateTrainingTable(thirdPlayerRikishi);
//			TrainingPopup->Show(); // Show the Noboru form
//			this->Hide();       // Hide the current form
//		}
//		else {
//			ShowMessage("No Rikishi in third Beya slot. Try another.");
//		}
//	}
//}

// Handle memory cleanup for the training popup when no longer needed (optional but good practice)
//void __fastcall TYourBeya::CleanupTrainingPopup() {
//	if (TrainingPopup) {
//		delete TrainingPopup; // Free memory
//		TrainingPopup = nullptr; // Set the pointer to nullptr to avoid dangling pointer issues
//	}
//}

void ResetSkillTrackers() {
	for (int i = 0; i < 3; i++) {
		StrengthTracker[i] = 0;
        WeightTracker[i] = 0;
        EnduranceTracker[i] = 0;
        TechniqueTracker[i] = 0;
        SpeedTracker[i] = 0;
        SpiritTracker[i] = 0;
    }
}

// Call Cleanup after usage (for example after closing the training phase)
void EndTraining() {
    TrainCPUrikishi(rikishiVector);
//	UpdateBanzukeGrid();
    ResetSkillTrackers();
    Application->ProcessMessages();
	isTrainingComplete = true;
	TrainingPhaseComplete();
//    YourBeya->CleanupTrainingPopup(); // Cleanup after the training phase
}

// When skipping training
void __fastcall TYourBeya::ButtonSkipTrainingClick(TObject *Sender) {
	if (isTrainingComplete && isBiddingComplete) {
		ShowMessage("Training is complete, they are waiting in the Dohyo!");
	}
	else if (isBiddingComplete == false) {
        ShowMessage("Bidding is not complete, please complete the bidding before ending training!");
	}
	else {

		TDialogService::MessageDialog("Do you want to end training?",
			TMsgDlgType::mtConfirmation, TMsgDlgButtons() << TMsgDlgBtn::mbYes << TMsgDlgBtn::mbNo,
			TMsgDlgBtn::mbNo, 0,
			[this](const TModalResult TrainResult) {
				if (TrainResult == mrYes) {
					EndTraining();
				}
			});
	}
}

bool CheckIfEnoughAP(int TrainingCost) {

	if (TrainingCost > players[0].AP) {
		return false;
	}
	else {
		for (auto& player : players) {
			if (player.AP > 0) {
				return true;  // At least one player has AP left
			}
			else if (TrainingCost == 0) {
				return true;
			}
		}

		return false;  // All players have no AP left
	}

}

void TYourBeya::CheckUpgrade(int rikishiIndex, String skillstring) {

	showResults = false; // Reset to "no" before showing the dialog
	UpgradeOk = true;

	auto rikishiOwnedByP1 = GetPlayerOwnedRikishi(rikishiVector, "P1");
	if (rikishiIndex >= rikishiOwnedByP1.size()) {
		ShowMessage("Player 1 does not have enough Rikishi.");
		return;
	}

	Rikishi& selectedRikishi = rikishiOwnedByP1[rikishiIndex].get();

	// Determine cost tiers based on age
	if (selectedRikishi.age < 27) {
		cost1 = 0; cost2 = 2; cost3 = 4;
	}
	else if (selectedRikishi.age < 31) {
		cost1 = 1; cost2 = 3; cost3 = 5;
	}
	else if (selectedRikishi.age < 34) {
		cost1 = 2; cost2 = 4; cost3 = -1;
	}
	else {
		cost1 = 2; cost2 = 4; cost3 = -1;
	}

	// AP checks and cost assignment based on skill level
	if (SkillTracker[rikishiIndex] == 0) {
		if (CheckIfEnoughAP(cost1)) {
			coststring = IntToStr(cost1);
		}
		else {
			ShowMessage("You cannot afford to upgrade this Rikishi. Try another Rikishi or end training.");
			UpgradeOk = false;
		}
	}
	else if (SkillTracker[rikishiIndex] == 1) {
		if (CheckIfEnoughAP(cost2)) {
			coststring = IntToStr(cost2);
		}
		else {
			ShowMessage("You cannot afford to upgrade this Rikishi. Try another Rikishi or end training.");
			UpgradeOk = false;
		}
	}
	else if (SkillTracker[rikishiIndex] == 2 && cost3 != -1) {
		if (CheckIfEnoughAP(cost3)) {
			coststring = IntToStr(cost3);
		}
		else {
			ShowMessage("You cannot afford to upgrade this Rikishi. Try another Rikishi or end training.");
			UpgradeOk = false;
		}
	}
	else if (SkillTracker[rikishiIndex] == 3 && cost3 != -1 && CheckIfEnoughAP(cost3)) {
		ShowMessage("You cannot upgrade skills for this Rikishi anymore, try upgrading the Rikishi spirit.");
		UpgradeOk = false;
	}
	else {
		ShowMessage("You cannot upgrade skills for this Rikishi anymore.");
		UpgradeOk = false;
	}

	if (UpgradeOk) {
		// Ask the player if they want to see training results
		TDialogService::MessageDialog("Would you like to train " + skillstring + "? It will cost $" + coststring + "!",
			TMsgDlgType::mtConfirmation, TMsgDlgButtons() << TMsgDlgBtn::mbYes << TMsgDlgBtn::mbNo,
			TMsgDlgBtn::mbNo, 0,
			[this, rikishiIndex, skillstring](const TModalResult TrainResult) {
				if (TrainResult == mrYes && UpgradeOk) {
					showResults = true;
					YourBeya->UpgradeSkill(rikishiIndex, skillstring);
				}
				else {
					showResults = false;
				}
			});
	}

}

void __fastcall TYourBeya::ImageStrength1Click(TObject *Sender) {
	CheckUpgrade(0, "strength");

}

void __fastcall TYourBeya::ImageStrength2Click(TObject *Sender) {
	CheckUpgrade(1, "strength");
}

void __fastcall TYourBeya::ImageStrength3Click(TObject *Sender) {
	CheckUpgrade(2, "strength");
}

void __fastcall TYourBeya::ImageWeight1Click(TObject *Sender) {
	CheckUpgrade(0, "weight");
}

void __fastcall TYourBeya::ImageWeight2Click(TObject *Sender) {
	CheckUpgrade(1, "weight");
}

void __fastcall TYourBeya::ImageWeight3Click(TObject *Sender) {
	CheckUpgrade(2, "weight");
}

void __fastcall TYourBeya::ImageEndurance1Click(TObject *Sender) {
	CheckUpgrade(0, "endurance");
}

void __fastcall TYourBeya::ImageEndurance2Click(TObject *Sender) {
	CheckUpgrade(1, "endurance");
}

void __fastcall TYourBeya::ImageEndurance3Click(TObject *Sender) {
	CheckUpgrade(2, "endurance");
}

void __fastcall TYourBeya::ImageTechnique1Click(TObject *Sender) {
	CheckUpgrade(0, "technique");
}

void __fastcall TYourBeya::ImageTechnique2Click(TObject *Sender) {
	CheckUpgrade(1, "technique");
}

void __fastcall TYourBeya::ImageTechnique3Click(TObject *Sender) {
	CheckUpgrade(2, "technique");
}

void __fastcall TYourBeya::ImageSpeed1Click(TObject *Sender) {
	CheckUpgrade(0, "speed");
}

void __fastcall TYourBeya::ImageSpeed2Click(TObject *Sender) {
	CheckUpgrade(1, "speed");
}

void __fastcall TYourBeya::ImageSpeed3Click(TObject *Sender) {
	CheckUpgrade(2, "speed");
}

void __fastcall TYourBeya::ImageYokozuna1Click(TObject *Sender) {
	CheckUpgrade(0, "spirit");
}

void __fastcall TYourBeya::ImageYokozuna2Click(TObject *Sender) {
	CheckUpgrade(1, "spirit");
}

void __fastcall TYourBeya::ImageYokozuna3Click(TObject *Sender) {
	CheckUpgrade(2, "spirit");
}

