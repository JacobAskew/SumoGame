//---------------------------------------------------------------------------
#include <fmx.h>
#include <FMX.Dialogs.hpp>
#include <System.UITypes.hpp>  // For colors
#include <map>  // If you still want to use maps
#include <FMX.Graphics.hpp>   // For TBitmap
#include <System.SysUtils.hpp>  // Required for UnicodeString conversion
#include <regex>
#include <unordered_map>
#include <unordered_set>
#include <random>
//---------------------------------------------------------------------------
#include "Banzuke.h"
#include "Street.h"
#include "Noboru.h"
#include "Beya.h"
#include "Dohyo.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.fmx"
#pragma hdrstop
//---------------------------------------------------------------------------
TBanzukeForm *BanzukeForm;

int fighter1SkillValue = 0;
int fighter1Total = 0;
int fighter2SkillValue = 0;
int fighter2Total = 0;
int Luck;
int winnerIdx;
int loserIdx;
//int i = 0;
std::string fighter1Tactic;
std::string fighter2Tactic;
std::string boutTactic;
int TotalBouts = 49;
int currentBoutIndex = 0;
bool isBanzukeComplete = false;
void BanzukePhaseComplete();

Rikishi* globalFighter1 = nullptr;
Rikishi* globalFighter2 = nullptr;

String VSPath = "C:\\Users\\zx123\\OneDrive\\Documents\\Embarcadero\\Studio\\Projects\\Images\\Vs2.png";

// Helper function to apply a tint to a pixel
TAlphaColor ApplyTintPixel(TAlphaColor originalColor, TAlphaColor tintColor) {
	// Extract RGB components from the original color
    uint8_t r = (originalColor >> 16) & 0xFF;
    uint8_t g = (originalColor >> 8) & 0xFF;
    uint8_t b = (originalColor >> 0) & 0xFF;

    // Extract RGB components from the tint color
    uint8_t tr = (tintColor >> 16) & 0xFF;
    uint8_t tg = (tintColor >> 8) & 0xFF;
    uint8_t tb = (tintColor >> 0) & 0xFF;

    // Simple blend of the original color with the tint (adjust as needed)
    r = (r + tr) / 2;
    g = (g + tg) / 2;
	b = (b + tb) / 2;

    // Recreate the tinted color and return it
    return (originalColor & 0xFF000000) | (r << 16) | (g << 8) | b;
}

// Function to apply tint to non-transparent pixels of the bitmap
void TintNoTransparent(TBitmap* bitmap, TAlphaColor tintColor) {
    if (!bitmap || bitmap->IsEmpty()) return;  // <-- Added null check

    TBitmapData bitmapData;
    if (bitmap->Map(TMapAccess::ReadWrite, bitmapData)) {
        for (int y = 0; y < bitmap->Height; ++y) {
            for (int x = 0; x < bitmap->Width; ++x) {
				TAlphaColor pixelColor = bitmapData.GetPixel(x, y);
                uint8_t alpha = (pixelColor >> 24) & 0xFF;

                if (alpha > 0) {
                    TAlphaColor tintedPixel = ApplyTintPixel(pixelColor, tintColor);
                    bitmapData.SetPixel(x, y, tintedPixel);
                }
            }
        }
        bitmap->Unmap(bitmapData);
    }
}

std::map<int, std::pair<int, int>> currentBoutResults; // Maps bout index to (winnerIdx, loserIdx)
//int currentBoutIndex = 0;  // The index of the current bout (for cyan highlighting)

// Function to set the result of a bout
void SetBoutResult(int boutIndex, int winnerIdx, int loserIdx) {
    currentBoutResults[boutIndex] = std::make_pair(winnerIdx, loserIdx);
}

void PopulateLeaderboardGrid() {
    // Create a copy of rikishiVector for sorting (leaves the original unchanged)
    std::vector<Rikishi> sortedRikishi = rikishiVector;

    // Sort the copy by wins in descending order
    std::sort(sortedRikishi.begin(), sortedRikishi.end(), [](const Rikishi& a, const Rikishi& b) {
        return a.wins > b.wins;
    });

    // Populate the grid with the sorted data
    for (int x = 0; x < 14; ++x) {
        if (x < sortedRikishi.size()) {
            std::string fullRank = sortedRikishi[x].rank; // Get full rank
            std::string shortRank; // Will store the extracted rank

            if (!fullRank.empty()) {
                shortRank += fullRank[0]; // Always take the first character

                // Check if the last character is a digit
                if (std::isdigit(fullRank.back())) {
                    // Find the last space to extract the full number
                    size_t lastSpace = fullRank.find_last_of(' ');
                    if (lastSpace != std::string::npos) {
                        shortRank += fullRank.substr(lastSpace + 1); // Append the full number
                    } else {
                        shortRank += fullRank.back(); // Default case if no space is found
                    }
                }
            }

            // Convert to AnsiString if needed
            AnsiString ansiShortRank = AnsiString(shortRank.c_str());

            // Combine the name, wins, and losses in a single string for each rikishi
            AnsiString fighterInfo = ansiShortRank + ":" +
                                     AnsiString(sortedRikishi[x].name.c_str()) + " (" +
                                     AnsiString(sortedRikishi[x].wins) + " / " +
                                     AnsiString(sortedRikishi[x].losses) + ")";

            // Determine the column based on the index (0 for first 7, 1 for next 7)
            int column = (x < 7) ? 0 : 1;
            int row = x % 7;  // Row index is 0-6 for both columns

            // Fill the grid cell with the combined string
            BanzukeForm->StringGridLeaderboard->Cells[column][row] = fighterInfo;
        } else {
            // In case there are fewer than 14 rikishi, clear the remaining cells
            BanzukeForm->StringGridLeaderboard->Cells[0][x] = "";
            BanzukeForm->StringGridLeaderboard->Cells[1][x] = "";
        }
    }
}

void UpdateTournamentGrid()
{

	BanzukeForm->StringGridTournament->Repaint();

	// Ensure NoboruForm and its grid exist
	if (!BanzukeForm || !BanzukeForm->StringGridTournament) {
		ShowMessage("Error: Tournament Grid is missing.");
		return;
	}

    // Define the ranks in order
	std::vector<std::string> TRanks = {
		"Y", "O", "S", "K",
		"M1", "M2", "M3", "M4",
		"M5", "M6", "M7", "M8",
		"M9", "M10", "J1", "J2"
	};

    // Define a fixed tournament schedule (pre-determined matchups)
    std::vector<std::pair<int, int>> TournamentSchedule[7] = {
        // Monday
		{ {11, 13}, {10, 12}, {7, 8}, {5, 6}, {4, 9}, {1, 2}, {0, 3} },
		// Tuesday
		{ {11, 12}, {9, 10}, {8, 13}, {3, 6}, {2, 7}, {1, 5}, {0, 4} },
		// Wednesday
		{ {9, 11}, {7, 13}, {5, 12}, {3, 10}, {2, 4}, {1, 8}, {0, 6} },
		// Thursday
		{ {8, 9}, {7, 12}, {6, 13}, {5, 10}, {4, 11}, {1, 3}, {0, 2} },
		// Friday
		{ {10, 13}, {9, 12}, {8, 11}, {3, 4}, {2, 5}, {1, 6}, {0, 7} },
		// Saturday
		{ {12, 13}, {7, 10}, {6, 11}, {3, 8}, {2, 9}, {1, 4}, {0, 5} },
		// Sunday
		{ {10, 11}, {9, 13}, {8, 12}, {6, 7}, {4, 5}, {2, 3}, {0, 1} }
    };

	// Populate the grid with matchups
	for (int day = 0; day < 7; day++) {
		for (int bout = 0; bout < 7; bout++) {
			int rikishi1_idx = TournamentSchedule[day][bout].first;
			int rikishi2_idx = TournamentSchedule[day][bout].second;

			std::string boutText = TRanks[rikishi1_idx] + " vs " + TRanks[rikishi2_idx];

			// Fill the grid correctly (no +1 offset)
			BanzukeForm->StringGridTournament->Cells[day][bout] = AnsiString(boutText.c_str());
		}
	}
}

void UpdateBoutGUI(Rikishi* fighter1, Rikishi* fighter2, TForm *form)
{

	std::regex numRegex(R"(\d+)");
    // Update Fighter 1 images
	TImage* imageFighter1 = dynamic_cast<TImage*>(form->FindComponent("ImageRikishi1"));
	if (!imageFighter1) {
		ShowMessage("Error: ImageRikishi1 component not found.");
		return;
	}
	if (imageFighter1) {
		AnsiString fullPath1 = RikishiPath + IntToStr(fighter1->spirit) + ".png";
		imageFighter1->Bitmap->LoadFromFile(fullPath1);
	}

    TImage* imageBelt1 = dynamic_cast<TImage*>(form->FindComponent("ImageBelt1"));
    if (imageBelt1) {
        AnsiString fullPathBelt1 = BeltPath + ".png";
        imageBelt1->Bitmap->LoadFromFile(fullPathBelt1);

		std::string colorStr1 = AnsiString(fighter1->colour).c_str();
		std::smatch match1;
//        std::regex numRegex(R"(\d+)");
        if (std::regex_search(colorStr1, match1, numRegex)) {
            UnicodeString extractedNumber1 = UnicodeString(match1.str().c_str());
            TAlphaColor color1 = (TAlphaColor)StrToUInt(extractedNumber1);
            TintNoTransparent(imageBelt1->Bitmap, color1);
        } else {
			ShowMessage("Invalid color format: " + fighter1->colour);
        }
    }

    TImage* imageYokozuna1 = dynamic_cast<TImage*>(form->FindComponent("ImageYokozuna1"));
    if (imageYokozuna1) {
		imageYokozuna1->Visible = (fighter1->rank == "Yokozuna");
		if (fighter1->rank == "Yokozuna") {
			AnsiString fullPathYokozuna1 = YokozunaPath + ".png";
            imageYokozuna1->Bitmap->LoadFromFile(fullPathYokozuna1);
        }
    }

    // Update Fighter 2 images
	TImage* imageFighter2 = dynamic_cast<TImage*>(form->FindComponent("ImageRikishi2"));
    if (imageFighter2) {
		AnsiString fullPath2 = RikishiPath + IntToStr(fighter2->spirit) + ".png";
        imageFighter2->Bitmap->LoadFromFile(fullPath2);
	}

    TImage* imageBelt2 = dynamic_cast<TImage*>(form->FindComponent("ImageBelt2"));
	if (imageBelt2) {
		AnsiString fullPathBelt2 = BeltPath + ".png";
        imageBelt2->Bitmap->LoadFromFile(fullPathBelt2);

		std::string colorStr2 = AnsiString(fighter2->colour).c_str();
		std::smatch match2;
        if (std::regex_search(colorStr2, match2, numRegex)) {
            UnicodeString extractedNumber2 = UnicodeString(match2.str().c_str());
            TAlphaColor color2 = (TAlphaColor)StrToUInt(extractedNumber2);
			TintNoTransparent(imageBelt2->Bitmap, color2);
		} else {
			ShowMessage("Invalid color format: " + fighter2->colour);
		}
	}

	TImage* imageYokozuna2 = dynamic_cast<TImage*>(form->FindComponent("ImageYokozuna2"));
	if (imageYokozuna2) {
		imageYokozuna2->Visible = (fighter2->rank == "Yokozuna");
		if (fighter2->rank == "Yokozuna") {
			AnsiString fullPathYokozuna2 = YokozunaPath + ".png";
			imageYokozuna2->Bitmap->LoadFromFile(fullPathYokozuna2);
		}
	}
}

void AssignFightersFromGrid()
{
//    for (const Rikishi& r : rikishiVector) {
//		ShowMessage("Rikishi: " + AnsiString(r.name.c_str()) + " with rank '" + AnsiString(r.rank.c_str()) + "'");
//	}

	if (currentBoutIndex >= 7 * 7) { // 7 days * 7 bouts per day
		ShowMessage("The Tournament is complete!");
		return;
	}

	int day = currentBoutIndex / 7;  // Get the current day (column)
	int bout = currentBoutIndex % 7; // Get the current bout (row)

	// Get the bout text from the grid
	AnsiString boutText = BanzukeForm->StringGridTournament->Cells[day][bout];

    // Extract the two rank strings from the bout text
    std::string boutStr = boutText.c_str();
    size_t vsPos = boutStr.find(" vs ");
    if (vsPos == std::string::npos) {
        ShowMessage("Error: Invalid bout format.");
		return;
    }

	std::string shortRank1 = boutStr.substr(0, vsPos);
    std::string shortRank2 = boutStr.substr(vsPos + 4); // Skip " vs "

    // Convert short ranks to long-form ranks
	std::string longRank1, longRank2;
	std::unordered_map<std::string, std::string> rankMap = {
        {"Y", "Yokozuna"}, {"O", "Ozeki"}, {"S", "Sekiwake"}, {"K", "Komusubi"},
        {"M1", "Maegashira 1"}, {"M2", "Maegashira 2"}, {"M3", "Maegashira 3"},
		{"M4", "Maegashira 4"}, {"M5", "Maegashira 5"}, {"M6", "Maegashira 6"},
        {"M7", "Maegashira 7"}, {"M8", "Maegashira 8"}, {"M9", "Maegashira 9"},
        {"M10", "Maegashira 10"}, {"J1", "Juryo 1"}, {"J2", "Juryo 2"}
    };

	auto it1 = rankMap.find(shortRank1);
	auto it2 = rankMap.find(shortRank2);
	if (it1 != rankMap.end()) longRank1 = it1->second;
	if (it2 != rankMap.end()) longRank2 = it2->second;

	if (longRank1.empty() || longRank2.empty()) {
		ShowMessage("Error: Invalid rank abbreviation in bout.");
		return;
	}

	// Find the Rikishi with the corresponding ranks
	Rikishi* ptrFighter1 = nullptr;
	Rikishi* ptrFighter2 = nullptr;

    for (Rikishi& r : rikishiVector) {
        if (r.rank == longRank1 && ptrFighter1 == nullptr) {
			ptrFighter1 = &r;
        } else if (r.rank == longRank2 && ptrFighter2 == nullptr) {
            ptrFighter2 = &r;
        }

        if (ptrFighter1 && ptrFighter2) {
			break; // Found both fighters, exit loop
        }
	}

	if (!ptrFighter1 || !ptrFighter2) {
		ShowMessage("Error: Fighters not found for ranks " + AnsiString(longRank1.c_str()) + " and " + AnsiString(longRank2.c_str()));
        return;
    }

	// Convert pointers to references
	Rikishi& fighter1 = *ptrFighter1;
    Rikishi& fighter2 = *ptrFighter2;

	if (fighter1.name.empty()) {
		ShowMessage("fighter1 is nullptr during AssignFightersFromGrid");
	}
	if (fighter2.name.empty()) {
		ShowMessage("fighter2 is nullptr during AssignFightersFromGrid");
	}

	globalFighter1 = nullptr;
	globalFighter2 = nullptr;
	globalFighter1 = ptrFighter1;
	globalFighter2 = ptrFighter2;

	// Now you can use fighter1 and fighter2 directly
	UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);

	// Update UI with fighter names
	BanzukeForm->EditFighter1->Text = AnsiString(globalFighter1->name.c_str()) + " (" + AnsiString(globalFighter1->owner.c_str()) + ")";
	BanzukeForm->EditFighter2->Text = AnsiString(globalFighter2->name.c_str()) + " (" + AnsiString(globalFighter2->owner.c_str()) + ")";

}

void RandomSkillForFighter(Rikishi& fighter, std::string& fighterTactic) {
	// Define skill choices as strings only
	const std::vector<std::string> skills = {
		"Strength", "Weight", "Technique", "Endurance", "Speed"
	};

	static std::random_device rd;
	static std::mt19937 gen(rd());
	std::uniform_int_distribution<int> dis(1, 6); // 1-6 roll

	int roll = dis(gen);
	if (roll <= 2) { // 1/3 chance for preferred skill
        fighterTactic = fighter.preferredSkill;
    } else { // 1/6 chance for each of the remaining skills
        // Adjust roll to pick one of the 4 remaining skills
        int remainingRoll = dis(gen) % 4;
        int count = 0;
        for (const auto& skill : skills) {
            if (skill != fighter.preferredSkill) {
                if (count == remainingRoll) {
                    fighterTactic = skill;
                    break;
                }
                count++;
            }
        }
    }

	if (fighterTactic.empty()) {
		fighterTactic = skills[std::rand() % skills.size()];
	}
}

void GetBoutTactic() {
	// If both players choose the same tactic, use that
	if (fighter1Tactic == fighter2Tactic) {
		boutTactic = fighter1Tactic;
	} else {
		// Define tactic dominance rules
		static const std::unordered_map<std::string, std::unordered_set<std::string>> tacticWins = {
			{"Strength", {"Weight", "Technique"}},
			{"Speed", {"Strength", "Endurance"}},
			{"Technique", {"Weight", "Speed"}},
			{"Endurance", {"Strength", "Technique"}},
			{"Weight", {"Endurance", "Speed"}}
		};

		auto it1 = tacticWins.find(fighter1Tactic);
		auto it2 = tacticWins.find(fighter2Tactic);

		if (it1 != tacticWins.end() && it1->second.count(fighter2Tactic)) {
			boutTactic = fighter1Tactic;
		} else if (it2 != tacticWins.end() && it2->second.count(fighter1Tactic)) {
			boutTactic = fighter2Tactic;
		} else {
			boutTactic = "Unknown";
		}
	}

    // Log the bout tactic
//    MainStreet->MemoLog->Lines->Add("The bout tactic is " + boutTactic + "!");
}

void FighterSkillValue(Rikishi& fighter, int& fighterSkillValue) {
	if (boutTactic == "Strength") {
		fighterSkillValue = fighter.strength; // Replace with actual value
	} else if (boutTactic == "Weight") {
		fighterSkillValue = fighter.weight; // Replace with actual value
	} else if (boutTactic == "Technique") {
		fighterSkillValue = fighter.technique; // Replace with actual value
	} else if (boutTactic == "Endurance") {
		fighterSkillValue = fighter.endurance; // Replace with actual value
	} else if (boutTactic == "Speed") {
		fighterSkillValue = fighter.speed; // Replace with actual value
    } else {
        fighterSkillValue = 0; // Default if no valid skill
		ShowMessage("Error: Invalid skill detected.");
	}
}

void HandleInjury(Rikishi& fighter, int& fighterTotal) {
	// Perform luck roll (0-6)
	Luck = std::rand() % 7;

    // Output the luck roll value
//	MainStreet->MemoLog->Lines->Add(fighter.name + " rolled a " + std::to_string(Luck) + " on the luck die.");

	// Add luck roll value to fighterTotal (you can adjust this logic as per your needs)
	fighterTotal += Luck;

    // Now, handle the injury part (same as before)
    if (Luck == 1) {
        // Randomly choose one of the 5 skills (strength, weight, endurance, technique, speed)
        int skillRoll = std::rand() % 5;
        std::string selectedSkill;
        bool injuryOccurred = false;

        // Determine which skill was selected
        switch (skillRoll) {
            case 0: selectedSkill = "Strength"; break;
            case 1: selectedSkill = "Weight"; break;
            case 2: selectedSkill = "Endurance"; break;
            case 3: selectedSkill = "Technique"; break;
			case 4: selectedSkill = "Speed"; break;
        }

        // Check if the selected skill is one that can cause injury (Endurance, Strength, Speed)
        if (selectedSkill == "Endurance" && !fighter.isInjuredEndurance) {
            fighter.isInjuredEndurance = true;
            injuryOccurred = true;
        } else if (selectedSkill == "Strength" && !fighter.isInjuredStrength) {
            fighter.isInjuredStrength = true;
            injuryOccurred = true;
        } else if (selectedSkill == "Speed" && !fighter.isInjuredSpeed) {
            fighter.isInjuredSpeed = true;
            injuryOccurred = true;
        }

        // If the injury bool is already true, the fighter gets a major injury
        if (injuryOccurred) {
            // Reduce the skill by 1
			if (selectedSkill == "Strength") {
				if (fighter.strength > 0) {
					fighter.strength--;
				}
				else {
					if (fighter.strengthLimit > 0) {
						fighter.strengthLimit--;
					}
					else {
						fighter.strength = 0;
					}
				}
			} else if (selectedSkill == "Endurance") {
				if (fighter.endurance > 0) {
					fighter.endurance--;
				}
				else {
					if (fighter.enduranceLimit > 0) {
						fighter.enduranceLimit--;
					}
					else {
						fighter.endurance = 0;
					}
				}
			} else if (selectedSkill == "Speed") {
				if (fighter.speed > 0) {
					fighter.speed--;
				}
				else {
					if (fighter.speed > 0) {
						fighter.speed--;
					}
					else {
						fighter.speed = 0;
					}
				}
			}

			// Log injury outcome
//            MainStreet->MemoLog->Lines->Add(fighter.name + " selected skill: " + selectedSkill + ". Injury status: " + (injuryOccurred ? "Injured" : "Not Injured"));
		}
	}
}

void Victory(int winner) {
//	Rikishi& refFighter1 = *fighter1;  // Dereference to a reference
//	Rikishi& refFighter2 = *fighter2;  // Dereference to a reference
    if (winner == 0) {
//        ShowMessage("Fighter 1 wins!");
		globalFighter1->wins += 1;
		globalFighter2->losses += 1;
		if (globalFighter1->isShaken) {
			globalFighter1->isShaken = false;
        }
		if ((globalFighter1->rank.find("Maegashira") != std::string::npos) &&
			(globalFighter2->rank == "Yokozuna" || globalFighter2->rank == "Ozeki")) {
			if (globalFighter1->spirit < 4) {
				globalFighter1->spirit += 1;
			}
		}
		if (globalFighter2->isShaken) {
			if (globalFighter2->spirit > 0) {
				globalFighter2->spirit -= 1;
            }
			globalFighter2->isShaken = false;
		} else {
			globalFighter2->isShaken = true;
        }
    }
    else if (winner == 1) {
//		ShowMessage("Fighter 2 wins!");
		globalFighter2->wins += 1;
		globalFighter1->losses += 1;
		if (globalFighter2->isShaken) {
			globalFighter2->isShaken = false;
        }
		if ((globalFighter2->rank.find("Maegashira") != std::string::npos) &&
			(globalFighter1->rank == "Yokozuna" || globalFighter1->rank == "Ozeki")) {
			if (globalFighter2->spirit < 4) {
				globalFighter2->spirit += 1;
			}
		}
		if (globalFighter1->isShaken) {
			if (globalFighter1->spirit > 0) {
				globalFighter1->spirit -= 1;
            }
			globalFighter1->isShaken = false;
		} else {
			globalFighter1->isShaken = true;
        }
    }
    else {
        ShowMessage("Error: Invalid winner input.");
    }
}


void TBanzukeForm::StartBanzuke() {
	isBanzukeComplete = false;  // Reset the Banzuke status
	currentBoutIndex = 0;    // Start from the first Rikishi
	UpdateTournamentGrid();
	AssignFightersFromGrid();
	TImage* imagevs = dynamic_cast<TImage*>(BanzukeForm->FindComponent("ImageVS"));
	AnsiString fullPathVS = VSPath;
	ImageVS->Bitmap->LoadFromFile(fullPathVS);
    PopulateLeaderboardGrid();
}

// Function to end the Banzuke phase
void EndBanzuke() {
	UpdateBanzukeGrid();
	isBanzukeComplete = true;  // Mark Banzuke as complete
	ShowMessage("Ending Banzuke Phase...");
	BanzukePhaseComplete();    // Call the function to complete the Banzuke phase in MainStreet.cpp
}
//---------------------------------------------------------------------------



void __fastcall TBanzukeForm::ButtonAutomateAllClick(TObject *Sender)
{
	if (isBanzukeComplete == false && isTrainingComplete == true) {

		PopulateLeaderboardGrid();

		for (int i = 0; i < 49; i++) {
			// Select skills
			AssignFightersFromGrid();

	//        ShowMessage("Current Bout: " + IntToStr(i));

			if (globalFighter1->wins > 7 || globalFighter1->wins < 0) {
				ShowMessage("Error: rikishi.wins has an invalid value: " + IntToStr(globalFighter1->wins));
			}
			if (globalFighter1->losses > 7 || globalFighter1->losses < 0) {
				ShowMessage("Error: rikishi.losses has an invalid value: " + IntToStr(globalFighter1->losses));
			}
			if (globalFighter2->wins > 7 || globalFighter2->wins < 0) {
				ShowMessage("Error: rikishi.wins has an invalid value: " + IntToStr(globalFighter2->wins));
			}
			if (globalFighter2->losses > 7 || globalFighter2->losses < 0) {
				ShowMessage("Error: rikishi.losses has an invalid value: " + IntToStr(globalFighter2->losses));
			}

	//        auto it = std::find_if(rikishiVector.begin(), rikishiVector.end(),
	//            [](const Rikishi& r) { return r.name == globalFighter1->name; });
	//
	//        if (it == rikishiVector.end()) {
	//            ShowMessage("Error: globalFighter1 points to an invalid Rikishi.");
	//        }
	//
	//        if (!globalFighter1) {
	//            ShowMessage("Error: globalFighter1 is nullptr.");
	//        }

			RandomSkillForFighter(*globalFighter1, fighter1Tactic);
			RandomSkillForFighter(*globalFighter2, fighter2Tactic);

	//		ShowMessage(AnsiString(fighter1Tactic.c_str()));
	//        ShowMessage(AnsiString(fighter2Tactic.c_str()));

			GetBoutTactic();
			FighterSkillValue(*globalFighter1, fighter1SkillValue);
			FighterSkillValue(*globalFighter2, fighter2SkillValue);

			fighter1Total = fighter1SkillValue;
			HandleInjury(*globalFighter1, fighter1Total);

			fighter2Total = fighter2SkillValue;
			HandleInjury(*globalFighter2, fighter2Total);

			if (globalFighter1->spirit == 4) {
				fighter1Total += 1;
	//            ShowMessage("Rikishi 1 has high spirits!");
			}
			if (globalFighter2->spirit == 4) {
				fighter2Total += 1;
	//			ShowMessage("Rikishi 2 has high spirits!");
			}

			if (i >= 42 && i < 49) {
				if (globalFighter1->wins == 3 && globalFighter1->losses == 3) {
					fighter1Total += 1;
				}
				if (globalFighter2->wins == 3 && globalFighter2->losses == 3) {
					fighter2Total += 1;
				}
			}

			if (fighter1Total > fighter2Total) {
				Victory(0);
			} else if (fighter1Total < fighter2Total) {
				Victory(1);
			} else {
	//            ShowMessage("Weight tiebreaker!");
				if (globalFighter1->weight > globalFighter2->weight) {
					Victory(0);
				} else if (globalFighter1->weight < globalFighter2->weight) {
					Victory(1);
				} else {
	//				ShowMessage("Technique tiebreaker!");
					if (globalFighter1->technique > globalFighter2->technique) {
						Victory(0);
					} else if (globalFighter1->technique < globalFighter2->technique) {
						Victory(1);
					} else {
//						ShowMessage("O...M...G... Chance tiebreaker!");
						int winner = std::rand() % 2;
						Victory(winner);
					}
				}
			}
			PopulateLeaderboardGrid();
			SetBoutResult(currentBoutIndex, winnerIdx, loserIdx);
			UpdateTournamentGrid();
			UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);
            Application->ProcessMessages();
			currentBoutIndex++;
			BanzukeForm->MemoBoutLog->Lines->Add("Battle over ...");
//            ShowMessage("Test");
		}  // <-- Correctly closed loop here

		PopulateLeaderboardGrid();
		SetBoutResult(currentBoutIndex, winnerIdx, loserIdx);
		UpdateTournamentGrid();
		UpdateBoutGUI(globalFighter1, globalFighter2, BanzukeForm);
		BanzukeForm->MemoBoutLog->Lines->Add("The fighting has finished.");
		EndBanzuke();
	}
	else {
		ShowMessage("The training phase is not complete. The sumo are not ready.");
    }
}


//---------------------------------------------------------------------------
__fastcall TBanzukeForm::TBanzukeForm(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TBanzukeForm::ButtonReturnStreetClick(TObject *Sender)
{
	MainStreet->Show(); // Show the main form
	this->Hide();     // Hide the second form
}
//---------------------------------------------------------------------------

void __fastcall TBanzukeForm::ButtonDohyoClick(TObject *Sender)
{
	DohyoForm->Show(); // Show the main form
	this->Hide();     // Hide the second form
}
//---------------------------------------------------------------------------

void __fastcall TBanzukeForm::StringGridTournamentDrawColumnCell(TObject *Sender,
	TCanvas * const Canvas, TColumn * const Column, const TRectF &Bounds,
	const int Row, const TValue &Value, const TGridDrawStates State)
{
    // Define colors
    TAlphaColor Green = TAlphaColorF::Create(0, 1, 0).ToAlphaColor();  // Winner color
    TAlphaColor Red = TAlphaColorF::Create(1, 0, 0).ToAlphaColor();    // Loser color
    TAlphaColor Black = TAlphaColorRec::Black;  // Default text color
    TAlphaColor Cyan = TAlphaColorF::Create(0, 1, 1, 0.75).ToAlphaColor(); // Highlight current bout

    // Ensure row and column indices are valid
    if (Row >= 7 || Column->Index >= 7) return;

    // Get column index (Day) and row index (Bout)
    int colIndex = Column->Index;
    int boutIndex = Row;

    // Get current bout ID
    int currentBout = colIndex * 7 + boutIndex;

    // Retrieve the cell text
    UnicodeString cellText = BanzukeForm->StringGridTournament->Cells[colIndex][boutIndex];

    // Convert UnicodeString to std::string
    std::string text = std::string(reinterpret_cast<const char*>(cellText.c_str()));
    size_t vsPos = text.find(" vs ");
    if (vsPos == std::string::npos) return;

    std::string rank1 = text.substr(0, vsPos);
    std::string rank2 = text.substr(vsPos + 4); // Skip " vs "

    // Convert std::string to UnicodeString for compatibility
    UnicodeString rank1U = UnicodeString(rank1.c_str());
    UnicodeString rank2U = UnicodeString(rank2.c_str());

    // **Determine text color for winner and loser**
    TAlphaColor rank1Color = Black;
    TAlphaColor rank2Color = Black;

    if (currentBoutResults.find(currentBout) != currentBoutResults.end()) {
        int winnerIdx = currentBoutResults[currentBout].first;
        int loserIdx = currentBoutResults[currentBout].second;

        if (rank1U == UnicodeString(Ranks[winnerIdx].c_str())) rank1Color = Green;
        if (rank1U == UnicodeString(Ranks[loserIdx].c_str())) rank1Color = Red;
        if (rank2U == UnicodeString(Ranks[winnerIdx].c_str())) rank2Color = Green;
        if (rank2U == UnicodeString(Ranks[loserIdx].c_str())) rank2Color = Red;
    }

    // Highlight the current bout in cyan
    if (currentBout == currentBoutIndex) {
        Canvas->Fill->Color = Cyan;
        Canvas->FillRect(Bounds, 0, 0, AllCorners, 1);
    }

    // **Calculate text widths for alignment**
    float vsWidth = Canvas->TextWidth(" vs ");
    float rank1Width = Canvas->TextWidth(rank1U);
    float rank2Width = Canvas->TextWidth(rank2U);

    // Calculate position to center the text
    float width = Bounds.Right - Bounds.Left;
    float startX = Bounds.Left + ((width - (rank1Width + vsWidth + rank2Width)) / 2);

    // **Draw the text with respective colors**
    // Draw rank1
    Canvas->Fill->Color = rank1Color;
    Canvas->FillText(TRectF(startX, Bounds.Top, startX + rank1Width, Bounds.Bottom),
                     rank1U, false, 1.0, TFillTextFlags(),
                     TTextAlign::Leading, TTextAlign::Center);

    // Draw " vs " in black
    Canvas->Fill->Color = Black;
    Canvas->FillText(TRectF(startX + rank1Width, Bounds.Top, startX + rank1Width + vsWidth, Bounds.Bottom),
                     " vs ", false, 1.0, TFillTextFlags(),
                     TTextAlign::Leading, TTextAlign::Center);

    // Draw rank2
    Canvas->Fill->Color = rank2Color;
    Canvas->FillText(TRectF(startX + rank1Width + vsWidth, Bounds.Top, startX + rank1Width + vsWidth + rank2Width, Bounds.Bottom),
                     rank2U, false, 1.0, TFillTextFlags(),
                     TTextAlign::Leading, TTextAlign::Center);
}

//void __fastcall TBanzukeForm::StringGridTournamentDrawColumnCell(TObject *Sender,
//	TCanvas * const Canvas, TColumn * const Column, const TRectF &Bounds,
//	const int Row, const TValue &Value, const TGridDrawStates State)
//{
//	// Define colors
//	TAlphaColor SemiTransparentCyan = TAlphaColorF::Create(0, 1, 1, 0.75).ToAlphaColor(); // Current bout
//	TAlphaColor Green = TAlphaColorF::Create(0, 1, 0).ToAlphaColor();  // Winner color
//	TAlphaColor Red = TAlphaColorF::Create(1, 0, 0).ToAlphaColor();    // Loser color
//
//	// Ensure row and column indices are valid
//	if (Row >= 7 || Column->Index >= 7) return;
//
//	// Get column index (Day) and row index (Bout)
//	int colIndex = Column->Index;
//	int boutIndex = Row;
//
//	// Get current bout ID
//	int currentBout = colIndex * 7 + boutIndex;
//
//    // **Highlight the current bout in cyan** (background highlight)
//	if (currentBout == currentBoutIndex) {
//        Canvas->Fill->Color = SemiTransparentCyan;
//		Canvas->FillRect(Bounds, 0, 0, AllCorners, 1);
//	}
//
//	// Retrieve the cell text
//	UnicodeString cellText = BanzukeForm->StringGridTournament->Cells[colIndex][boutIndex];
//
//    // Convert UnicodeString to std::string
//    std::string text = std::string(reinterpret_cast<const char*>(cellText.c_str()));
//	size_t vsPos = text.find(" vs ");
//    if (vsPos == std::string::npos) return;
//
//    std::string rank1 = text.substr(0, vsPos);
//	std::string rank2 = text.substr(vsPos + 4); // Skip " vs "
//
//    // Convert std::string to UnicodeString for compatibility
//    UnicodeString rank1U = UnicodeString(rank1.c_str());
//	UnicodeString rank2U = UnicodeString(rank2.c_str());
//
//    // **Highlight the previous bout's winner and loser** (color highlight)
//	TAlphaColor rank1Color = TAlphaColorRec::Black;
//	TAlphaColor rank2Color = TAlphaColorRec::Black;
//
//	if (currentBoutResults.find(currentBout) != currentBoutResults.end()) {
//		int winnerIdx = currentBoutResults[currentBout].first;
//		int loserIdx = currentBoutResults[currentBout].second;
//
//		if (rank1U == UnicodeString(Ranks[winnerIdx].c_str())) rank1Color = Green;
//		if (rank1U == UnicodeString(Ranks[loserIdx].c_str())) rank1Color = Red;
//		if (rank2U == UnicodeString(Ranks[winnerIdx].c_str())) rank2Color = Green;
//		if (rank2U == UnicodeString(Ranks[loserIdx].c_str())) rank2Color = Red;
//	}
//
//	// **Calculate text and rectangle widths**
//	float textWidth = Canvas->TextWidth(cellText);  // Ensure function is called
//	float vsWidth = Canvas->TextWidth(" vs ");
//    float rank1Width = Canvas->TextWidth(rank1U);
//	float rank2Width = Canvas->TextWidth(rank2U);
//
//    // Calculate the total width of all text
//    float totalWidth = rank1Width + vsWidth + rank2Width;
//
//	// Calculate position to center the text
//	float width = Bounds.Right - Bounds.Left; // Calculate width directly
//	float startX = Bounds.Left + ((width - textWidth) / 2); // Center alignment
//
//    // **Draw background rectangle around the text (highlight)**
//	// Draw a rectangle for rank1, " vs ", and rank2 areas (with padding)
//	Canvas->Fill->Color = SemiTransparentCyan;
//	Canvas->FillRect(TRectF(startX, Bounds.Top, startX + rank1Width, Bounds.Bottom), 0, 0, AllCorners, 1);
//	Canvas->FillRect(TRectF(startX + rank1Width + vsWidth, Bounds.Top, startX + rank1Width + vsWidth + rank2Width, Bounds.Bottom), 0, 0, AllCorners, 1);
//
//	// **Draw the text on top of the highlighted background**
//	// Draw rank1
//	Canvas->Fill->Color = rank1Color;
//	Canvas->FillText(TRectF(startX, Bounds.Top, startX + rank1Width, Bounds.Bottom),
//					 rank1U, false, 1.0, TFillTextFlags(),
//					 TTextAlign::Leading, TTextAlign::Center);
//
//	// Draw " vs " in black
//	Canvas->Fill->Color = TAlphaColorRec::Black;
//	Canvas->FillText(TRectF(startX + rank1Width, Bounds.Top, startX + rank1Width + vsWidth, Bounds.Bottom),
//					 " vs ", false, 1.0, TFillTextFlags(),
//					 TTextAlign::Leading, TTextAlign::Center);
//
//	// Draw rank2
//	Canvas->Fill->Color = rank2Color;
//	Canvas->FillText(TRectF(startX + rank1Width + vsWidth, Bounds.Top, startX + rank1Width + vsWidth + rank2Width, Bounds.Bottom),
//					 rank2U, false, 1.0, TFillTextFlags(),
//					 TTextAlign::Leading, TTextAlign::Center);
//}

